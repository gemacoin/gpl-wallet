{"ast":null,"code":"var fs = require('fs');\n\nvar path = require('path');\n\nvar Chain = require('traverse-chain');\n/**\n * Outline the APIs.\n */\n\n\nvar find = module.exports = {// file:      function([pat,] root, callback) {}\n  // dir:       function([pat,] root, callback) {}\n  // eachfile:  function([pat,] root, action) {}\n  // eachdir:   function([pat,] root, action) {}\n  // fileSync:  function([pat,] root) {}\n  // dirSync:   function([pat,] root) {}\n  // use::      function(options) {}\n};\nvar fss = {};\n/**\n *  Error handler wrapper.\n */\n\nfss.errorHandler = function (err) {\n  if (err) {\n    if (find.__errorHandler) {\n      find.__errorHandler(err);\n    } else {\n      throw err;\n    }\n  }\n};\n\nvar error = {\n  notExist: function (name) {\n    return new Error(name + ' does not exist.');\n  }\n};\n\nvar is = function () {\n  function existed(name) {\n    return fs.existsSync(name);\n  }\n\n  function fsType(type) {\n    return function (name) {\n      try {\n        return fs.lstatSync(name)['is' + type]();\n      } catch (err) {\n        if (!/^(EPERM|EACCES)$/.test(err.code)) {\n          fss.errorHandler(err);\n        } else {\n          console.warn('Warning: Cannot access %s', name);\n        }\n      }\n    };\n  }\n\n  function objType(type) {\n    return function (input) {\n      if (type === 'Function') {\n        return typeof input === 'function';\n      }\n\n      return {}.toString.call(input) === '[object ' + type + ']';\n    };\n  }\n\n  return {\n    existed: existed,\n    file: fsType('File'),\n    directory: fsType('Directory'),\n    symbolicLink: fsType('SymbolicLink'),\n    string: objType('String'),\n    regexp: objType('RegExp'),\n    func: objType('Function')\n  };\n}();\n/**\n *  Method injection for handling errors.\n */\n\n\n['readdir', 'lstat'].forEach(function (method) {\n  fss[method] = function (path, callback) {\n    var origin = fs[method];\n    return origin.apply(fs, [path, function (err) {\n      fss.errorHandler(err);\n      return callback.apply(null, arguments);\n    }]);\n  };\n});\n/**\n * Enhancement for fs.readlink && fs.readlinkSync.\n */\n\nfss.readlink = function (name, fn, depth) {\n  if (depth == undefined) depth = 5;\n\n  if (!is.existed(name) && depth < 5) {\n    return fn(path.resolve(name));\n  }\n\n  var isSymbolicLink = is.symbolicLink(name);\n\n  if (!isSymbolicLink) {\n    fn(path.resolve(name));\n  } else if (depth) {\n    fs.realpath(name, function (err, origin) {\n      if (err && /^(ENOENT|ELOOP|EPERM|EACCES)$/.test(err.code)) {\n        fn(name);\n      } else {\n        if (err) {\n          fss.errorHandler(err);\n        } else {\n          fss.readlink(origin, fn, --depth);\n        }\n      }\n    });\n  } else {\n    fn(isSymbolicLink ? '' : path.resolve(name));\n  }\n};\n\nfss.readlinkSync = function (name, depth) {\n  if (depth == undefined) depth = 5;\n\n  if (!is.existed(name) && depth < 5) {\n    return path.resolve(name);\n  }\n\n  var isSymbolicLink = is.symbolicLink(name);\n\n  if (!isSymbolicLink) {\n    return path.resolve(name);\n  } else if (depth) {\n    var origin;\n\n    try {\n      origin = fs.realpathSync(name);\n    } catch (err) {\n      if (/^(ENOENT|ELOOP|EPERM|EACCES)$/.test(err.code)) {\n        return name;\n      } else {\n        fss.errorHandler(err);\n      }\n    }\n\n    return fss.readlinkSync(origin, --depth);\n  } else {\n    return isSymbolicLink ? '' : path.resolve(name);\n  }\n};\n/**\n * Check pattern against the path\n */\n\n\nvar compare = function (pat, name) {\n  var str = path.basename(name);\n  return is.regexp(pat) && pat.test(name) || is.string(pat) && pat === str;\n};\n/**\n * Traverse a directory recursively and asynchronously.\n *\n * @param {String} root\n * @param {String} type\n * @param {Function} action\n * @param {Function} callback\n * @param {Chain} c\n * @api private\n */\n\n\nvar traverseAsync = function (root, type, action, callback, c) {\n  if (!is.existed(root)) {\n    fss.errorHandler(error.notExist(root));\n  }\n\n  var originRoot = root;\n\n  if (is.symbolicLink(root)) {\n    root = fss.readlinkSync(root);\n  }\n\n  if (is.directory(root)) {\n    fss.readdir(root, function (err, all) {\n      var chain = Chain();\n      all && all.forEach(function (dir) {\n        dir = path.join(originRoot, dir);\n        chain.add(function () {\n          var handleFile = function () {\n            if (type == 'file') action(dir);\n            process.nextTick(function () {\n              chain.next();\n            });\n          };\n\n          var handleDir = function (skip) {\n            if (type == 'dir') action(dir);\n            if (skip) chain.next();else process.nextTick(function () {\n              traverseAsync(dir, type, action, callback, chain);\n            });\n          };\n\n          var isSymbolicLink = is.symbolicLink(dir);\n\n          if (is.directory(dir)) {\n            handleDir();\n          } else if (isSymbolicLink) {\n            fss.readlink(dir, function (origin) {\n              if (origin) {\n                if (is.existed(origin) && is.directory(origin)) {\n                  handleDir(isSymbolicLink);\n                } else {\n                  handleFile();\n                }\n              } else {\n                chain.next();\n              }\n            });\n          } else {\n            handleFile();\n          }\n        });\n      });\n      chain.traverse(function () {\n        c ? c.next() : callback();\n      });\n    });\n  }\n};\n/**\n * Traverse a directory recursively.\n *\n * @param {String} root\n * @param {String} type\n * @param {Function} action\n * @return {Array} the result\n * @api private\n */\n\n\nvar traverseSync = function (root, type, action) {\n  if (!is.existed(root)) throw error.notExist(root);\n  var originRoot = root;\n\n  if (is.symbolicLink(root)) {\n    root = fss.readlinkSync(root);\n  }\n\n  if (is.directory(root)) {\n    fs.readdirSync(root).forEach(function (dir) {\n      dir = path.join(originRoot, dir);\n\n      var handleDir = function (skip) {\n        if (type == 'dir') action(dir);\n        if (skip) return;\n        traverseSync(dir, type, action);\n      };\n\n      var handleFile = function () {\n        if (type == 'file') action(dir);\n      };\n\n      var isSymbolicLink = is.symbolicLink(dir);\n\n      if (is.directory(dir)) {\n        handleDir();\n      } else if (isSymbolicLink) {\n        var origin = fss.readlinkSync(dir);\n\n        if (origin) {\n          if (is.existed(origin) && is.directory(origin)) {\n            handleDir(isSymbolicLink);\n          } else {\n            handleFile();\n          }\n        }\n      } else {\n        handleFile();\n      }\n    });\n  }\n};\n\n['file', 'dir'].forEach(function (type) {\n  /**\n   * `find.file` and `find.dir`\n   *\n   * Find files or sub-directories in a given directory and\n   * passes the result in an array as a whole. This follows\n   * the default callback style of nodejs, think about `fs.readdir`,\n   *\n   * @param {RegExp|String} pat\n   * @param {String} root\n   * @param {Function} fn\n   * @api public\n   */\n  find[type] = function (pat, root, fn) {\n    var buffer = [];\n\n    if (arguments.length == 2) {\n      fn = root;\n      root = pat;\n      pat = '';\n    }\n\n    process.nextTick(function () {\n      traverseAsync(root, type, function (n) {\n        buffer.push(n);\n      }, function () {\n        if (is.func(fn) && pat) {\n          fn(buffer.filter(function (n) {\n            return compare(pat, n);\n          }));\n        } else {\n          fn(buffer);\n        }\n      });\n    });\n    return {\n      error: function (handler) {\n        if (is.func(handler)) {\n          find.__errorHandler = handler;\n        }\n      }\n    };\n  };\n  /**\n   * `find.eachfile` and `find.eachdir`\n   *\n   * Find files or sub-directories in a given directory and\n   * apply with a given action to each result immediately\n   * rather than pass them back as an array.\n   *\n   * @param {RegExp|String} pat\n   * @param {String} root\n   * @param {Function} action\n   * @return {Object} for chain methods\n   * @api public\n   *\n   */\n\n\n  find['each' + type] = function (pat, root, action) {\n    var callback = function () {};\n\n    if (arguments.length == 2) {\n      action = root;\n      root = pat;\n      pat = '';\n    }\n\n    process.nextTick(function () {\n      traverseAsync(root, type, function (n) {\n        if (!is.func(action)) return;\n\n        if (!pat || compare(pat, n)) {\n          action(n);\n        }\n      }, callback);\n    });\n    return {\n      end: function (fn) {\n        if (is.func(fn)) {\n          callback = fn;\n        }\n\n        return this;\n      },\n      error: function (handler) {\n        if (is.func(handler)) {\n          find.__errorHandler = handler;\n        }\n\n        return this;\n      }\n    };\n  };\n  /**\n   * `find.fileSync` and `find.dirSync`\n   *\n   * Find files or sub-directories in a given directory synchronously\n   * and returns the result as an array. This follows the default 'Sync'\n   * methods of nodejs, think about `fs.readdirSync`,\n   *\n   * @param {RegExp|String} pat\n   * @param {String} root\n   * @return {Array} the result\n   * @api public\n   */\n\n\n  find[type + 'Sync'] = function (pat, root) {\n    var buffer = [];\n\n    if (arguments.length == 1) {\n      root = pat;\n      pat = '';\n    }\n\n    traverseSync(root, type, function (n) {\n      buffer.push(n);\n    });\n    return pat && buffer.filter(function (n) {\n      return compare(pat, n);\n    }) || buffer;\n  };\n});\nvar fsMethods = ['existsSync', 'lstatSync', 'realpath', 'realpathSync', 'readdir', 'readdirSync'];\n/**\n * Configuations for internal usage\n *\n * @param {Object} options\n * @api public\n */\n\nfind.use = function (options) {\n  if (options && options.fs) {\n    if (fsMethods.every(n => !!options.fs[n])) {\n      fs = options.fs;\n    } else {\n      throw new Error('The provided fs object is not compatiable with native fs.');\n    }\n  }\n\n  return find;\n};","map":{"version":3,"sources":["/home/imentus/spl-token-wallet/node_modules/find/index.js"],"names":["fs","require","path","Chain","find","module","exports","fss","errorHandler","err","__errorHandler","error","notExist","name","Error","is","existed","existsSync","fsType","type","lstatSync","test","code","console","warn","objType","input","toString","call","file","directory","symbolicLink","string","regexp","func","forEach","method","callback","origin","apply","arguments","readlink","fn","depth","undefined","resolve","isSymbolicLink","realpath","readlinkSync","realpathSync","compare","pat","str","basename","traverseAsync","root","action","c","originRoot","readdir","all","chain","dir","join","add","handleFile","process","nextTick","next","handleDir","skip","traverse","traverseSync","readdirSync","buffer","length","n","push","filter","handler","end","fsMethods","use","options","every"],"mappings":"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","sourcesContent":["var fs = require('fs');\nvar path = require('path');\nvar Chain = require('traverse-chain');\n\n\n/**\n * Outline the APIs.\n */\nvar find = module.exports = {\n\n  // file:      function([pat,] root, callback) {}\n  // dir:       function([pat,] root, callback) {}\n\n  // eachfile:  function([pat,] root, action) {}\n  // eachdir:   function([pat,] root, action) {}\n\n  // fileSync:  function([pat,] root) {}\n  // dirSync:   function([pat,] root) {}\n  // use::      function(options) {}\n\n};\n\n\nvar fss = {};\n\n/**\n *  Error handler wrapper.\n */\nfss.errorHandler = function(err) {\n  if (err) {\n    if (find.__errorHandler) {\n      find.__errorHandler(err);\n    } else {\n      throw err;\n    }\n  }\n};\n\n\nvar error = {\n  notExist: function(name) {\n    return new Error(name + ' does not exist.');\n  }\n};\n\n\nvar is = (function() {\n  function existed(name) {\n    return fs.existsSync(name);\n  }\n  function fsType(type) {\n    return function(name) {\n      try {\n        return fs.lstatSync(name)['is' + type]();\n      } catch(err) {\n        if (!/^(EPERM|EACCES)$/.test(err.code)) {\n          fss.errorHandler(err);\n        }\n        else {\n          console.warn('Warning: Cannot access %s', name);\n        }\n      }\n    }\n  }\n  function objType(type) {\n    return function(input) {\n      if (type === 'Function') {\n        return typeof input === 'function';\n      }\n      return ({}).toString.call(input) === '[object ' + type +  ']';\n    }\n  }\n  return {\n    existed:      existed,\n    file:         fsType('File'),\n    directory:    fsType('Directory'),\n    symbolicLink: fsType('SymbolicLink'),\n\n    string:       objType('String'),\n    regexp:       objType('RegExp'),\n    func:         objType('Function')\n  };\n}());\n\n\n/**\n *  Method injection for handling errors.\n */\n['readdir', 'lstat'].forEach(function(method) {\n  fss[method] = function(path, callback) {\n    var origin = fs[method];\n    return origin.apply(fs, [path, function(err) {\n      fss.errorHandler(err);\n      return callback.apply(null, arguments);\n    }]);\n  }\n});\n\n\n/**\n * Enhancement for fs.readlink && fs.readlinkSync.\n */\nfss.readlink = function(name, fn, depth) {\n  if (depth == undefined) depth = 5;\n  if (!is.existed(name) && (depth < 5)) {\n    return fn(path.resolve(name));\n  }\n  var isSymbolicLink = is.symbolicLink(name);\n  if (!isSymbolicLink) {\n    fn(path.resolve(name));\n  } else if (depth) {\n    fs.realpath(name, function(err, origin) {\n      if (err && /^(ENOENT|ELOOP|EPERM|EACCES)$/.test(err.code)) {\n        fn(name);\n      } else {\n        if (err) {\n          fss.errorHandler(err);\n        } else {\n          fss.readlink(origin, fn, --depth);\n        }\n      }\n    });\n  } else {\n    fn(isSymbolicLink ? '' : path.resolve(name));\n  }\n}\n\nfss.readlinkSync = function(name, depth) {\n  if (depth == undefined) depth = 5;\n  if (!is.existed(name) && depth < 5) {\n    return path.resolve(name);\n  }\n  var isSymbolicLink = is.symbolicLink(name);\n  if (!isSymbolicLink) {\n    return path.resolve(name);\n  } else if (depth) {\n    var origin;\n    try {\n      origin = fs.realpathSync(name);\n    } catch (err) {\n      if (/^(ENOENT|ELOOP|EPERM|EACCES)$/.test(err.code)) {\n        return name;\n      } else {\n        fss.errorHandler(err);\n      }\n    }\n    return fss.readlinkSync(origin, --depth);\n  } else {\n    return isSymbolicLink ? '' : path.resolve(name);\n  }\n}\n\n\n/**\n * Check pattern against the path\n */\nvar compare = function(pat, name) {\n  var str = path.basename(name);\n  return (\n       is.regexp(pat) && pat.test(name)\n    || is.string(pat) && pat === str\n  );\n};\n\n\n/**\n * Traverse a directory recursively and asynchronously.\n *\n * @param {String} root\n * @param {String} type\n * @param {Function} action\n * @param {Function} callback\n * @param {Chain} c\n * @api private\n */\nvar traverseAsync = function(root, type, action, callback, c) {\n  if (!is.existed(root)) {\n    fss.errorHandler(error.notExist(root))\n  }\n\n  var originRoot = root;\n  if (is.symbolicLink(root)) {\n    root = fss.readlinkSync(root);\n  }\n\n  if (is.directory(root)) {\n    fss.readdir(root, function(err, all) {\n      var chain = Chain();\n      all && all.forEach(function(dir) {\n        dir = path.join(originRoot, dir);\n        chain.add(function() {\n          var handleFile = function() {\n            if (type == 'file') action(dir);\n            process.nextTick(function() { chain.next() });\n          }\n          var handleDir = function(skip) {\n            if (type == 'dir') action(dir);\n            if (skip) chain.next();\n            else process.nextTick(function() { traverseAsync(dir, type, action, callback, chain)});\n          }\n          var isSymbolicLink = is.symbolicLink(dir);\n          if (is.directory(dir)) {\n            handleDir();\n          } else if (isSymbolicLink) {\n            fss.readlink(dir, function(origin) {\n              if (origin) {\n                if (is.existed(origin) && is.directory(origin)) {\n                  handleDir(isSymbolicLink)\n                } else {\n                  handleFile()\n                }\n              } else {\n                chain.next();\n              }\n            });\n          } else {\n            handleFile();\n          }\n        })\n      });\n      chain.traverse(function() {\n        c ? c.next() : callback();\n      });\n    });\n  }\n}\n\n\n/**\n * Traverse a directory recursively.\n *\n * @param {String} root\n * @param {String} type\n * @param {Function} action\n * @return {Array} the result\n * @api private\n */\nvar traverseSync = function(root, type, action) {\n  if (!is.existed(root)) throw error.notExist(root);\n  var originRoot = root;\n  if (is.symbolicLink(root)) {\n    root = fss.readlinkSync(root);\n  }\n  if (is.directory(root)) {\n    fs.readdirSync(root).forEach(function(dir) {\n      dir = path.join(originRoot, dir);\n      var handleDir = function(skip) {\n        if (type == 'dir') action(dir);\n        if (skip) return;\n        traverseSync(dir, type, action);\n      }\n      var handleFile = function() {\n        if (type == 'file') action(dir);\n      }\n      var isSymbolicLink = is.symbolicLink(dir);\n      if (is.directory(dir)) {\n        handleDir();\n      } else if (isSymbolicLink) {\n        var origin = fss.readlinkSync(dir);\n        if (origin) {\n          if (is.existed(origin) && is.directory(origin)) {\n            handleDir(isSymbolicLink);\n          } else {\n            handleFile();\n          }\n        }\n      } else {\n        handleFile();\n      }\n    });\n  }\n};\n\n\n['file', 'dir'].forEach(function(type) {\n\n  /**\n   * `find.file` and `find.dir`\n   *\n   * Find files or sub-directories in a given directory and\n   * passes the result in an array as a whole. This follows\n   * the default callback style of nodejs, think about `fs.readdir`,\n   *\n   * @param {RegExp|String} pat\n   * @param {String} root\n   * @param {Function} fn\n   * @api public\n   */\n  find[type] = function(pat, root, fn) {\n    var buffer = [];\n    if (arguments.length == 2) {\n      fn = root;\n      root = pat;\n      pat = '';\n    }\n    process.nextTick(function() {\n      traverseAsync(\n        root\n      , type\n      , function(n) { buffer.push(n);}\n      , function() {\n          if (is.func(fn) && pat) {\n            fn(buffer.filter(function(n) {\n              return compare(pat, n);\n            }));\n          } else {\n            fn(buffer);\n          }\n        }\n      );\n    });\n    return {\n      error: function(handler) {\n        if (is.func(handler)) {\n          find.__errorHandler = handler;\n        }\n      }\n    }\n  }\n\n  /**\n   * `find.eachfile` and `find.eachdir`\n   *\n   * Find files or sub-directories in a given directory and\n   * apply with a given action to each result immediately\n   * rather than pass them back as an array.\n   *\n   * @param {RegExp|String} pat\n   * @param {String} root\n   * @param {Function} action\n   * @return {Object} for chain methods\n   * @api public\n   *\n   */\n  find['each' + type] = function(pat, root, action) {\n    var callback = function() {}\n    if (arguments.length == 2) {\n      action = root;\n      root = pat;\n      pat = '';\n    }\n    process.nextTick(function() {\n      traverseAsync(\n          root\n        , type\n        , function(n) {\n            if (!is.func(action)) return;\n            if (!pat || compare(pat, n)) {\n              action(n);\n            }\n          }\n        , callback\n      );\n    });\n    return {\n      end: function(fn) {\n        if (is.func(fn)) {\n          callback = fn;\n        }\n        return this;\n      },\n      error: function(handler) {\n        if (is.func(handler)) {\n          find.__errorHandler = handler;\n        }\n        return this;\n      }\n    };\n  }\n\n  /**\n   * `find.fileSync` and `find.dirSync`\n   *\n   * Find files or sub-directories in a given directory synchronously\n   * and returns the result as an array. This follows the default 'Sync'\n   * methods of nodejs, think about `fs.readdirSync`,\n   *\n   * @param {RegExp|String} pat\n   * @param {String} root\n   * @return {Array} the result\n   * @api public\n   */\n  find[type + 'Sync'] = function(pat, root) {\n    var buffer = [];\n    if (arguments.length == 1) {\n      root = pat;\n      pat = '';\n    }\n    traverseSync(root, type, function(n) {\n      buffer.push(n);\n    });\n    return pat && buffer.filter(function(n) {\n      return compare(pat, n);\n    }) || buffer;\n  }\n\n});\n\n\nvar fsMethods = [\n  'existsSync',\n  'lstatSync',\n  'realpath',\n  'realpathSync',\n  'readdir',\n  'readdirSync'\n];\n\n\n/**\n * Configuations for internal usage\n *\n * @param {Object} options\n * @api public\n */\nfind.use = function(options) {\n  if (options && options.fs) {\n    if (fsMethods.every(n => !!options.fs[n])) {\n      fs = options.fs;\n    } else {\n      throw new Error('The provided fs object is not compatiable with native fs.');\n    }\n  }\n  return find;\n}\n"]},"metadata":{},"sourceType":"script"}