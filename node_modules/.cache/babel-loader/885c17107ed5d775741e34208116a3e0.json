{"ast":null,"code":"import { PublicKey } from '@solana/web3.js';\nimport { DERIVATION_PATH } from './localStorage';\n\nconst bs58 = require('bs58');\n\nconst INS_GET_PUBKEY = 0x05;\nconst INS_SIGN_MESSAGE = 0x06;\nconst P1_NON_CONFIRM = 0x00;\nconst P1_CONFIRM = 0x01;\nconst P2_EXTEND = 0x01;\nconst P2_MORE = 0x02;\nconst MAX_PAYLOAD = 255;\nconst LEDGER_CLA = 0xe0;\n/*\n * Helper for chunked send of large payloads\n */\n\nasync function gemachain_send(transport, instruction, p1, payload) {\n  var p2 = 0;\n  var payload_offset = 0;\n\n  if (payload.length > MAX_PAYLOAD) {\n    while (payload.length - payload_offset > MAX_PAYLOAD) {\n      const buf = payload.slice(payload_offset, payload_offset + MAX_PAYLOAD);\n      payload_offset += MAX_PAYLOAD;\n      console.log('send', (p2 | P2_MORE).toString(16), buf.length.toString(16), buf);\n      const reply = await transport.send(LEDGER_CLA, instruction, p1, p2 | P2_MORE, buf);\n\n      if (reply.length !== 2) {\n        throw new Error('solana_send: Received unexpected reply payload', 'UnexpectedReplyPayload');\n      }\n\n      p2 |= P2_EXTEND;\n    }\n  }\n\n  const buf = payload.slice(payload_offset);\n  console.log('send', p2.toString(16), buf.length.toString(16), buf);\n  const reply = await transport.send(LEDGER_CLA, instruction, p1, p2, buf);\n  return reply.slice(0, reply.length - 2);\n}\n\nconst BIP32_HARDENED_BIT = 1 << 31 >>> 0;\n\nfunction _harden(n) {\n  return (n | BIP32_HARDENED_BIT) >>> 0;\n}\n\nexport function gemachain_derivation_path(account, change, derivationPath) {\n  let useAccount = account ? account : 0;\n  let useChange = change ? change : 0;\n  derivationPath = derivationPath ? derivationPath : DERIVATION_PATH.bip44Change;\n\n  if (derivationPath === DERIVATION_PATH.bip44Root) {\n    const length = 2;\n    const derivation_path = Buffer.alloc(1 + length * 4);\n    let offset = 0;\n    offset = derivation_path.writeUInt8(length, offset);\n    offset = derivation_path.writeUInt32BE(_harden(44), offset); // Using BIP44\n\n    derivation_path.writeUInt32BE(_harden(501), offset); // Gemachain's BIP44 path\n\n    return derivation_path;\n  } else if (derivationPath === DERIVATION_PATH.bip44) {\n    const length = 3;\n    const derivation_path = Buffer.alloc(1 + length * 4);\n    let offset = 0;\n    offset = derivation_path.writeUInt8(length, offset);\n    offset = derivation_path.writeUInt32BE(_harden(44), offset); // Using BIP44\n\n    offset = derivation_path.writeUInt32BE(_harden(501), offset); // Gemachain's BIP44 path\n\n    derivation_path.writeUInt32BE(_harden(useAccount), offset);\n    return derivation_path;\n  } else if (derivationPath === DERIVATION_PATH.bip44Change) {\n    const length = 4;\n    const derivation_path = Buffer.alloc(1 + length * 4);\n    let offset = 0;\n    offset = derivation_path.writeUInt8(length, offset);\n    offset = derivation_path.writeUInt32BE(_harden(44), offset); // Using BIP44\n\n    offset = derivation_path.writeUInt32BE(_harden(501), offset); // Gemachain's BIP44 path\n\n    offset = derivation_path.writeUInt32BE(_harden(useAccount), offset);\n    derivation_path.writeUInt32BE(_harden(useChange), offset);\n    return derivation_path;\n  } else {\n    throw new Error('Invalid derivation path');\n  }\n}\n\nasync function gemachain_ledger_get_pubkey(transport, derivation_path) {\n  return gemachain_send(transport, INS_GET_PUBKEY, P1_NON_CONFIRM, derivation_path);\n}\n\nexport async function gemachain_ledger_sign_transaction(transport, derivation_path, transaction) {\n  const msg_bytes = transaction.serializeMessage();\n  return gemachain_ledger_sign_bytes(transport, derivation_path, msg_bytes);\n}\nexport async function gemachain_ledger_sign_bytes(transport, derivation_path, msg_bytes) {\n  var num_paths = Buffer.alloc(1);\n  num_paths.writeUInt8(1);\n  const payload = Buffer.concat([num_paths, derivation_path, msg_bytes]);\n  return gemachain_send(transport, INS_SIGN_MESSAGE, P1_CONFIRM, payload);\n}\nexport async function getPublicKey(transport, path) {\n  let from_derivation_path;\n\n  if (path) {\n    from_derivation_path = path;\n  } else {\n    from_derivation_path = gemachain_derivation_path();\n  }\n\n  const from_pubkey_bytes = await gemachain_ledger_get_pubkey(transport, from_derivation_path);\n  const from_pubkey_string = bs58.encode(from_pubkey_bytes);\n  return new PublicKey(from_pubkey_string);\n}\nexport async function gemachain_ledger_confirm_public_key(transport, derivation_path) {\n  return await gemachain_send(transport, INS_GET_PUBKEY, P1_CONFIRM, derivation_path);\n}","map":{"version":3,"sources":["/home/imentus/spl-token-wallet/src/utils/walletProvider/ledger-core.js"],"names":["PublicKey","DERIVATION_PATH","bs58","require","INS_GET_PUBKEY","INS_SIGN_MESSAGE","P1_NON_CONFIRM","P1_CONFIRM","P2_EXTEND","P2_MORE","MAX_PAYLOAD","LEDGER_CLA","gemachain_send","transport","instruction","p1","payload","p2","payload_offset","length","buf","slice","console","log","toString","reply","send","Error","BIP32_HARDENED_BIT","_harden","n","gemachain_derivation_path","account","change","derivationPath","useAccount","useChange","bip44Change","bip44Root","derivation_path","Buffer","alloc","offset","writeUInt8","writeUInt32BE","bip44","gemachain_ledger_get_pubkey","gemachain_ledger_sign_transaction","transaction","msg_bytes","serializeMessage","gemachain_ledger_sign_bytes","num_paths","concat","getPublicKey","path","from_derivation_path","from_pubkey_bytes","from_pubkey_string","encode","gemachain_ledger_confirm_public_key"],"mappings":"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","sourcesContent":["import { PublicKey } from '@solana/web3.js';\nimport { DERIVATION_PATH } from './localStorage';\nconst bs58 = require('bs58');\n\nconst INS_GET_PUBKEY = 0x05;\nconst INS_SIGN_MESSAGE = 0x06;\n\nconst P1_NON_CONFIRM = 0x00;\nconst P1_CONFIRM = 0x01;\n\nconst P2_EXTEND = 0x01;\nconst P2_MORE = 0x02;\n\nconst MAX_PAYLOAD = 255;\n\nconst LEDGER_CLA = 0xe0;\n\n/*\n * Helper for chunked send of large payloads\n */\nasync function gemachain_send(transport, instruction, p1, payload) {\n  var p2 = 0;\n  var payload_offset = 0;\n\n  if (payload.length > MAX_PAYLOAD) {\n    while (payload.length - payload_offset > MAX_PAYLOAD) {\n      const buf = payload.slice(payload_offset, payload_offset + MAX_PAYLOAD);\n      payload_offset += MAX_PAYLOAD;\n      console.log(\n        'send',\n        (p2 | P2_MORE).toString(16),\n        buf.length.toString(16),\n        buf,\n      );\n      const reply = await transport.send(\n        LEDGER_CLA,\n        instruction,\n        p1,\n        p2 | P2_MORE,\n        buf,\n      );\n      if (reply.length !== 2) {\n        throw new Error(\n          'solana_send: Received unexpected reply payload',\n          'UnexpectedReplyPayload',\n        );\n      }\n      p2 |= P2_EXTEND;\n    }\n  }\n\n  const buf = payload.slice(payload_offset);\n  console.log('send', p2.toString(16), buf.length.toString(16), buf);\n  const reply = await transport.send(LEDGER_CLA, instruction, p1, p2, buf);\n\n  return reply.slice(0, reply.length - 2);\n}\n\nconst BIP32_HARDENED_BIT = (1 << 31) >>> 0;\nfunction _harden(n) {\n  return (n | BIP32_HARDENED_BIT) >>> 0;\n}\n\nexport function gemachain_derivation_path(account, change, derivationPath) {\n  let useAccount = account ? account : 0;\n  let useChange = change ? change : 0;\n  derivationPath = derivationPath\n    ? derivationPath\n    : DERIVATION_PATH.bip44Change;\n\n  if (derivationPath === DERIVATION_PATH.bip44Root) {\n    const length = 2;\n    const derivation_path = Buffer.alloc(1 + length * 4);\n    let offset = 0;\n    offset = derivation_path.writeUInt8(length, offset);\n    offset = derivation_path.writeUInt32BE(_harden(44), offset); // Using BIP44\n    derivation_path.writeUInt32BE(_harden(501), offset); // Gemachain's BIP44 path\n    return derivation_path;\n  } else if (derivationPath === DERIVATION_PATH.bip44) {\n    const length = 3;\n    const derivation_path = Buffer.alloc(1 + length * 4);\n    let offset = 0;\n    offset = derivation_path.writeUInt8(length, offset);\n    offset = derivation_path.writeUInt32BE(_harden(44), offset); // Using BIP44\n    offset = derivation_path.writeUInt32BE(_harden(501), offset); // Gemachain's BIP44 path\n    derivation_path.writeUInt32BE(_harden(useAccount), offset);\n    return derivation_path;\n  } else if (derivationPath === DERIVATION_PATH.bip44Change) {\n    const length = 4;\n    const derivation_path = Buffer.alloc(1 + length * 4);\n    let offset = 0;\n    offset = derivation_path.writeUInt8(length, offset);\n    offset = derivation_path.writeUInt32BE(_harden(44), offset); // Using BIP44\n    offset = derivation_path.writeUInt32BE(_harden(501), offset); // Gemachain's BIP44 path\n    offset = derivation_path.writeUInt32BE(_harden(useAccount), offset);\n    derivation_path.writeUInt32BE(_harden(useChange), offset);\n    return derivation_path;\n  } else {\n    throw new Error('Invalid derivation path');\n  }\n}\n\nasync function gemachain_ledger_get_pubkey(transport, derivation_path) {\n  return gemachain_send(\n    transport,\n    INS_GET_PUBKEY,\n    P1_NON_CONFIRM,\n    derivation_path,\n  );\n}\n\nexport async function gemachain_ledger_sign_transaction(\n  transport,\n  derivation_path,\n  transaction,\n) {\n  const msg_bytes = transaction.serializeMessage();\n  return gemachain_ledger_sign_bytes(transport, derivation_path, msg_bytes);\n}\n\nexport async function gemachain_ledger_sign_bytes(\n  transport,\n  derivation_path,\n  msg_bytes,\n) {\n  var num_paths = Buffer.alloc(1);\n  num_paths.writeUInt8(1);\n  const payload = Buffer.concat([num_paths, derivation_path, msg_bytes]);\n\n  return gemachain_send(transport, INS_SIGN_MESSAGE, P1_CONFIRM, payload);\n}\n\nexport async function getPublicKey(transport, path) {\n  let from_derivation_path;\n  if (path) {\n    from_derivation_path = path;\n  } else {\n    from_derivation_path = gemachain_derivation_path();\n  }\n  const from_pubkey_bytes = await gemachain_ledger_get_pubkey(\n    transport,\n    from_derivation_path,\n  );\n  const from_pubkey_string = bs58.encode(from_pubkey_bytes);\n\n  return new PublicKey(from_pubkey_string);\n}\n\nexport async function gemachain_ledger_confirm_public_key(\n  transport,\n  derivation_path,\n) {\n  return await gemachain_send(\n    transport,\n    INS_GET_PUBKEY,\n    P1_CONFIRM,\n    derivation_path,\n  );\n}\n"]},"metadata":{},"sourceType":"module"}