{"ast":null,"code":"import bs58 from 'bs58';\nimport { Message, StakeInstruction, StakeProgram, SystemInstruction, SystemProgram } from '@solana/web3.js';\nimport { decodeInstruction, Market, MARKETS, SETTLE_FUNDS_BASE_WALLET_INDEX, SETTLE_FUNDS_QUOTE_WALLET_INDEX, NEW_ORDER_OPEN_ORDERS_INDEX, NEW_ORDER_OWNER_INDEX, NEW_ORDER_V3_OPEN_ORDERS_INDEX, NEW_ORDER_V3_OWNER_INDEX } from '@project-serum/serum';\nimport { decodeTokenInstruction } from '@project-serum/token';\nimport { PublicKey } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from './tokens/instructions';\nconst RAYDIUM_STAKE_PROGRAM_ID = new PublicKey('EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q');\nconst RAYDIUM_LP_PROGRAM_ID = new PublicKey('RVKd61ztZW9GUwhRbbLoYVRE5Xf1B2tVscKqwZqXgEr');\nconst MANGO_PROGRAM_ID = new PublicKey('JD3bq9hGdy38PuWQ4h2YJpELmHVGPPfFSuFkpzAd9zfu');\nconst MANGO_PROGRAM_ID_V2 = new PublicKey('5fNfvyp5czQVX77yoACa3JJVEhdRaWjPuazuWgjhTqEH');\nconst marketCache = {};\nlet marketCacheConnection = null;\nconst cacheDuration = 15 * 1000;\nexport const decodeMessage = async (connection, wallet, message) => {\n  // get message object\n  const transactionMessage = Message.from(message);\n\n  if (!(transactionMessage === null || transactionMessage === void 0 ? void 0 : transactionMessage.instructions) || !(transactionMessage === null || transactionMessage === void 0 ? void 0 : transactionMessage.accountKeys)) {\n    return;\n  } // get owned keys (used for security checks)\n\n\n  const publicKey = wallet.publicKey; // get instructions\n\n  const instructions = [];\n\n  for (var i = 0; i < transactionMessage.instructions.length; i++) {\n    let transactionInstruction = transactionMessage.instructions[i];\n    const instruction = await toInstruction(connection, publicKey, transactionMessage === null || transactionMessage === void 0 ? void 0 : transactionMessage.accountKeys, transactionInstruction, transactionMessage, i);\n    instructions.push({ ...instruction,\n      rawData: transactionInstruction === null || transactionInstruction === void 0 ? void 0 : transactionInstruction.data\n    });\n  }\n\n  return instructions;\n};\n\nconst toInstruction = async (connection, publicKey, accountKeys, instruction, transactionMessage, index) => {\n  if ((instruction === null || instruction === void 0 ? void 0 : instruction.data) == null || !(instruction === null || instruction === void 0 ? void 0 : instruction.accounts) || !(instruction === null || instruction === void 0 ? void 0 : instruction.programIdIndex)) {\n    return;\n  } // get instruction data\n\n\n  const decoded = bs58.decode(instruction.data);\n  const programId = getAccountByIndex([instruction.programIdIndex], accountKeys, 0);\n\n  if (!programId) {\n    return null;\n  }\n\n  try {\n    if (programId.equals(SystemProgram.programId)) {\n      console.log('[' + index + '] Handled as system instruction');\n      return handleSystemInstruction(publicKey, instruction, accountKeys);\n    } else if (programId.equals(StakeProgram.programId)) {\n      console.log('[' + index + '] Handled as stake instruction');\n      return handleStakeInstruction(publicKey, instruction, accountKeys);\n    } else if (programId.equals(TOKEN_PROGRAM_ID)) {\n      console.log('[' + index + '] Handled as token instruction');\n      return handleTokenInstruction(publicKey, instruction, accountKeys);\n    } else if (MARKETS.some(market => market.programId && market.programId.equals(programId))) {\n      console.log('[' + index + '] Handled as dex instruction');\n      let decodedInstruction = decodeInstruction(decoded);\n      return await handleDexInstruction(connection, instruction, accountKeys, decodedInstruction);\n    } else if (programId.equals(RAYDIUM_STAKE_PROGRAM_ID)) {\n      console.log('[' + index + '] Handled as raydium stake instruction'); // @ts-ignore\n\n      const decodedInstruction = decodeStakeInstruction(decoded);\n      return await handleRayStakeInstruction(connection, instruction, accountKeys, decodedInstruction);\n    } else if (programId.equals(RAYDIUM_LP_PROGRAM_ID)) {\n      console.log('[' + index + '] Handled as raydium lp instruction'); // @ts-ignore\n\n      const decodedInstruction = decodeLpInstruction(decoded);\n      return await handleRayLpInstruction(connection, instruction, accountKeys, decodedInstruction);\n    } else if (programId.equals(MANGO_PROGRAM_ID) || programId.equals(MANGO_PROGRAM_ID_V2)) {\n      console.log('[' + index + '] Handled as mango markets instruction'); // @ts-ignore\n\n      let decodedInstruction = decodeMangoInstruction(decoded);\n      return await handleMangoInstruction(connection, instruction, accountKeys, decodedInstruction);\n    } else {\n      return {\n        type: 'Unknown',\n        accountMetas: instruction.accounts.map(index => ({\n          publicKey: accountKeys[index],\n          isWritable: transactionMessage.isAccountWritable(index)\n        })),\n        programId\n      };\n    }\n  } catch (e) {\n    console.log(`Failed to decode instruction: ${e}`);\n  } // all decodings failed\n\n\n  console.log('[' + index + '] Failed, data: ' + JSON.stringify(decoded));\n  return;\n};\n\nconst handleMangoInstruction = async (connection, instruction, accountKeys, decodedInstruction) => {\n  // TODO\n  return {\n    type: 'mango'\n  };\n};\n\nconst handleRayStakeInstruction = async (connection, instruction, accountKeys, decodedInstruction) => {\n  // TODO\n  return {\n    type: 'raydium'\n  };\n};\n\nconst handleRayLpInstruction = async (connection, instruction, accountKeys, decodedInstruction) => {\n  // TODO\n  return {\n    type: 'raydium'\n  };\n};\n\nconst decodeMangoInstruction = () => {\n  // TODO\n  return undefined;\n};\n\nconst decodeStakeInstruction = () => {\n  // TODO\n  return undefined;\n};\n\nconst decodeLpInstruction = () => {\n  // TODO\n  return undefined;\n};\n\nconst handleDexInstruction = async (connection, instruction, accountKeys, decodedInstruction) => {\n  if (!decodedInstruction || Object.keys(decodedInstruction).length > 1) {\n    return;\n  }\n\n  const {\n    accounts,\n    programIdIndex\n  } = instruction; // get market info\n\n  const marketInfo = accountKeys && MARKETS.find(market => accountKeys.findIndex(accountKey => accountKey.equals(market.address)) > -1); // get market\n\n  let market, programIdAddress;\n\n  try {\n    const marketAddress = (marketInfo === null || marketInfo === void 0 ? void 0 : marketInfo.address) || getAccountByIndex(accounts, accountKeys, 0);\n    programIdAddress = (marketInfo === null || marketInfo === void 0 ? void 0 : marketInfo.programId) || getAccountByIndex([programIdIndex], accountKeys, 0);\n    const strAddress = marketAddress.toBase58();\n    const now = new Date().getTime();\n\n    if (!(connection === marketCacheConnection && strAddress in marketCache && now - marketCache[strAddress].ts < cacheDuration)) {\n      marketCacheConnection = connection;\n      console.log('Loading market', strAddress);\n      marketCache[strAddress] = {\n        market: await Market.load(connection, marketAddress, {}, programIdAddress),\n        ts: now\n      };\n    }\n\n    market = marketCache[strAddress].market;\n  } catch (e) {\n    console.log('Error loading market: ' + e.message);\n  } // get data\n\n\n  const type = Object.keys(decodedInstruction)[0];\n  let data = decodedInstruction[type];\n\n  if (type === 'settleFunds') {\n    const settleFundsData = getSettleFundsData(accounts, accountKeys);\n\n    if (!settleFundsData) {\n      return;\n    } else {\n      data = { ...data,\n        ...settleFundsData\n      };\n    }\n  } else if (type === 'newOrder') {\n    const newOrderData = getNewOrderData(accounts, accountKeys);\n    data = { ...data,\n      ...newOrderData\n    };\n  } else if (type === 'newOrderV3') {\n    const newOrderData = getNewOrderV3Data(accounts, accountKeys);\n    data = { ...data,\n      ...newOrderData\n    };\n  }\n\n  return {\n    type,\n    data,\n    market,\n    marketInfo\n  };\n};\n\nconst handleSystemInstruction = (publicKey, instruction, accountKeys) => {\n  const {\n    programIdIndex,\n    accounts,\n    data\n  } = instruction;\n\n  if (!programIdIndex || !accounts || !data) {\n    return;\n  } // construct system instruction\n\n\n  const systemInstruction = {\n    programId: accountKeys[programIdIndex],\n    keys: accounts.map(accountIndex => ({\n      pubkey: accountKeys[accountIndex]\n    })),\n    data: bs58.decode(data)\n  }; // get layout\n\n  let decoded;\n  const type = SystemInstruction.decodeInstructionType(systemInstruction);\n\n  switch (type) {\n    case 'Create':\n      decoded = SystemInstruction.decodeCreateAccount(systemInstruction);\n      break;\n\n    case 'CreateWithSeed':\n      decoded = SystemInstruction.decodeCreateWithSeed(systemInstruction);\n      break;\n\n    case 'Allocate':\n      decoded = SystemInstruction.decodeAllocate(systemInstruction);\n      break;\n\n    case 'AllocateWithSeed':\n      decoded = SystemInstruction.decodeAllocateWithSeed(systemInstruction);\n      break;\n\n    case 'Assign':\n      decoded = SystemInstruction.decodeAssign(systemInstruction);\n      break;\n\n    case 'AssignWithSeed':\n      decoded = SystemInstruction.decodeAssignWithSeed(systemInstruction);\n      break;\n\n    case 'Transfer':\n      decoded = SystemInstruction.decodeTransfer(systemInstruction);\n      break;\n\n    case 'AdvanceNonceAccount':\n      decoded = SystemInstruction.decodeNonceAdvance(systemInstruction);\n      break;\n\n    case 'WithdrawNonceAccount':\n      decoded = SystemInstruction.decodeNonceWithdraw(systemInstruction);\n      break;\n\n    case 'InitializeNonceAccount':\n      decoded = SystemInstruction.decodeNonceInitialize(systemInstruction);\n      break;\n\n    case 'AuthorizeNonceAccount':\n      decoded = SystemInstruction.decodeNonceAuthorize(systemInstruction);\n      break;\n\n    default:\n      return;\n  }\n\n  if (!decoded || decoded.fromPubkey && !publicKey.equals(decoded.fromPubkey)) {\n    return;\n  }\n\n  return {\n    type: 'system' + type,\n    data: decoded\n  };\n};\n\nconst handleStakeInstruction = (publicKey, instruction, accountKeys) => {\n  const {\n    programIdIndex,\n    accounts,\n    data\n  } = instruction;\n\n  if (!programIdIndex || !accounts || !data) {\n    return;\n  } // construct stake instruction\n\n\n  const stakeInstruction = {\n    programId: accountKeys[programIdIndex],\n    keys: accounts.map(accountIndex => ({\n      pubkey: accountKeys[accountIndex]\n    })),\n    data: bs58.decode(data)\n  };\n  let decoded;\n  const type = StakeInstruction.decodeInstructionType(stakeInstruction);\n\n  switch (type) {\n    case 'AuthorizeWithSeed':\n      decoded = StakeInstruction.decodeAuthorizeWithSeed(stakeInstruction);\n      break;\n\n    case 'Authorize':\n      decoded = StakeInstruction.decodeAuthorize(stakeInstruction);\n      break;\n\n    case 'Deactivate':\n      decoded = StakeInstruction.decodeDeactivate(stakeInstruction);\n      break;\n\n    case 'Delegate':\n      decoded = StakeInstruction.decodeDelegate(stakeInstruction);\n      break;\n\n    case 'Initialize':\n      decoded = StakeInstruction.decodeInitialize(stakeInstruction); // Lockup inactive if all zeroes\n\n      const lockup = decoded.lockup;\n\n      if (lockup && lockup.unixTimestamp === 0 && lockup.epoch === 0 && lockup.custodian.equals(PublicKey.default)) {\n        decoded.lockup = 'Inactive';\n      } else {\n        decoded.lockup = `unixTimestamp: ${lockup.unixTimestamp}, custodian: ${lockup.epoch}, custodian: ${lockup.custodian.toBase58()}`;\n      } // flatten authorized to allow address render\n\n\n      decoded.authorizedStaker = decoded.authorized.staker;\n      decoded.authorizedWithdrawer = decoded.authorized.withdrawer;\n      delete decoded.authorized;\n      break;\n\n    case 'Split':\n      decoded = StakeInstruction.decodeSplit(stakeInstruction);\n      break;\n\n    case 'Withdraw':\n      decoded = StakeInstruction.decodeWithdraw(stakeInstruction);\n      break;\n\n    default:\n      return;\n  }\n\n  if (!decoded || decoded.fromPubkey && !publicKey.equals(decoded.fromPubkey)) {\n    return;\n  }\n\n  return {\n    type: 'stake' + type,\n    data: decoded\n  };\n};\n\nconst handleTokenInstruction = (publicKey, instruction, accountKeys) => {\n  const {\n    programIdIndex,\n    accounts,\n    data\n  } = instruction;\n\n  if (!programIdIndex || !accounts || !data) {\n    return;\n  } // construct token instruction\n\n\n  const tokenInstruction = {\n    programId: accountKeys[programIdIndex],\n    keys: accounts.map(accountIndex => ({\n      pubkey: accountKeys[accountIndex]\n    })),\n    data: bs58.decode(data)\n  };\n  let decoded = decodeTokenInstruction(tokenInstruction);\n  return {\n    type: decoded.type,\n    data: decoded.params\n  };\n};\n\nconst getNewOrderData = (accounts, accountKeys) => {\n  const openOrdersPubkey = getAccountByIndex(accounts, accountKeys, NEW_ORDER_OPEN_ORDERS_INDEX);\n  const ownerPubkey = getAccountByIndex(accounts, accountKeys, NEW_ORDER_OWNER_INDEX);\n  return {\n    openOrdersPubkey,\n    ownerPubkey\n  };\n};\n\nconst getNewOrderV3Data = (accounts, accountKeys) => {\n  const openOrdersPubkey = getAccountByIndex(accounts, accountKeys, NEW_ORDER_V3_OPEN_ORDERS_INDEX);\n  const ownerPubkey = getAccountByIndex(accounts, accountKeys, NEW_ORDER_V3_OWNER_INDEX);\n  return {\n    openOrdersPubkey,\n    ownerPubkey\n  };\n};\n\nconst getSettleFundsData = (accounts, accountKeys) => {\n  const basePubkey = getAccountByIndex(accounts, accountKeys, SETTLE_FUNDS_BASE_WALLET_INDEX);\n  const quotePubkey = getAccountByIndex(accounts, accountKeys, SETTLE_FUNDS_QUOTE_WALLET_INDEX);\n\n  if (!basePubkey || !quotePubkey) {\n    return;\n  }\n\n  return {\n    basePubkey,\n    quotePubkey\n  };\n};\n\nconst getAccountByIndex = (accounts, accountKeys, accountIndex) => {\n  const index = accounts.length > accountIndex && accounts[accountIndex];\n  return (accountKeys === null || accountKeys === void 0 ? void 0 : accountKeys.length) > index && accountKeys[index];\n};","map":{"version":3,"sources":["/home/imentus/spl-token-wallet/src/utils/transactions.ts"],"names":["bs58","Message","StakeInstruction","StakeProgram","SystemInstruction","SystemProgram","decodeInstruction","Market","MARKETS","SETTLE_FUNDS_BASE_WALLET_INDEX","SETTLE_FUNDS_QUOTE_WALLET_INDEX","NEW_ORDER_OPEN_ORDERS_INDEX","NEW_ORDER_OWNER_INDEX","NEW_ORDER_V3_OPEN_ORDERS_INDEX","NEW_ORDER_V3_OWNER_INDEX","decodeTokenInstruction","PublicKey","TOKEN_PROGRAM_ID","RAYDIUM_STAKE_PROGRAM_ID","RAYDIUM_LP_PROGRAM_ID","MANGO_PROGRAM_ID","MANGO_PROGRAM_ID_V2","marketCache","marketCacheConnection","cacheDuration","decodeMessage","connection","wallet","message","transactionMessage","from","instructions","accountKeys","publicKey","i","length","transactionInstruction","instruction","toInstruction","push","rawData","data","index","accounts","programIdIndex","decoded","decode","programId","getAccountByIndex","equals","console","log","handleSystemInstruction","handleStakeInstruction","handleTokenInstruction","some","market","decodedInstruction","handleDexInstruction","decodeStakeInstruction","handleRayStakeInstruction","decodeLpInstruction","handleRayLpInstruction","decodeMangoInstruction","handleMangoInstruction","type","accountMetas","map","isWritable","isAccountWritable","e","JSON","stringify","undefined","Object","keys","marketInfo","find","findIndex","accountKey","address","programIdAddress","marketAddress","strAddress","toBase58","now","Date","getTime","ts","load","settleFundsData","getSettleFundsData","newOrderData","getNewOrderData","getNewOrderV3Data","systemInstruction","accountIndex","pubkey","decodeInstructionType","decodeCreateAccount","decodeCreateWithSeed","decodeAllocate","decodeAllocateWithSeed","decodeAssign","decodeAssignWithSeed","decodeTransfer","decodeNonceAdvance","decodeNonceWithdraw","decodeNonceInitialize","decodeNonceAuthorize","fromPubkey","stakeInstruction","decodeAuthorizeWithSeed","decodeAuthorize","decodeDeactivate","decodeDelegate","decodeInitialize","lockup","unixTimestamp","epoch","custodian","default","authorizedStaker","authorized","staker","authorizedWithdrawer","withdrawer","decodeSplit","decodeWithdraw","tokenInstruction","params","openOrdersPubkey","ownerPubkey","basePubkey","quotePubkey"],"mappings":"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","sourcesContent":["import bs58 from 'bs58';\nimport { Connection, Message, StakeInstruction, StakeProgram, SystemInstruction, SystemProgram } from '@solana/web3.js';\nimport {\n  decodeInstruction,\n  Market,\n  MARKETS,\n  SETTLE_FUNDS_BASE_WALLET_INDEX,\n  SETTLE_FUNDS_QUOTE_WALLET_INDEX,\n  NEW_ORDER_OPEN_ORDERS_INDEX,\n  NEW_ORDER_OWNER_INDEX,\n  NEW_ORDER_V3_OPEN_ORDERS_INDEX,\n  NEW_ORDER_V3_OWNER_INDEX,\n} from '@project-serum/serum';\nimport { decodeTokenInstruction } from '@project-serum/token';\nimport { PublicKey } from '@solana/web3.js';\nimport { TOKEN_PROGRAM_ID } from './tokens/instructions';\nimport { Wallet } from './wallet';\n\nconst RAYDIUM_STAKE_PROGRAM_ID = new PublicKey(\n  'EhhTKczWMGQt46ynNeRX1WfeagwwJd7ufHvCDjRxjo5Q',\n);\nconst RAYDIUM_LP_PROGRAM_ID = new PublicKey(\n  'RVKd61ztZW9GUwhRbbLoYVRE5Xf1B2tVscKqwZqXgEr',\n);\n\nconst MANGO_PROGRAM_ID = new PublicKey(\n  'JD3bq9hGdy38PuWQ4h2YJpELmHVGPPfFSuFkpzAd9zfu',\n);\nconst MANGO_PROGRAM_ID_V2 = new PublicKey(\n  '5fNfvyp5czQVX77yoACa3JJVEhdRaWjPuazuWgjhTqEH',\n);\n\nconst marketCache = {};\nlet marketCacheConnection = null;\nconst cacheDuration = 15 * 1000;\n\nexport const decodeMessage = async (connection: Connection, wallet: Wallet, message: Buffer) => {\n  // get message object\n  const transactionMessage = Message.from(message);\n  if (!transactionMessage?.instructions || !transactionMessage?.accountKeys) {\n    return;\n  }\n\n  // get owned keys (used for security checks)\n  const publicKey = wallet.publicKey;\n\n  // get instructions\n  const instructions: any[] = [];\n  for (var i = 0; i < transactionMessage.instructions.length; i++) {\n    let transactionInstruction = transactionMessage.instructions[i];\n    const instruction = await toInstruction(\n      connection,\n      publicKey,\n      transactionMessage?.accountKeys,\n      transactionInstruction,\n      transactionMessage,\n      i,\n    );\n    instructions.push({\n      ...instruction,\n      rawData: transactionInstruction?.data,\n    });\n  }\n  return instructions;\n};\n\nconst toInstruction = async (\n  connection: Connection,\n  publicKey: PublicKey,\n  accountKeys,\n  instruction,\n  transactionMessage: Message,\n  index: number,\n) => {\n  if (\n    instruction?.data == null ||\n    !instruction?.accounts ||\n    !instruction?.programIdIndex\n  ) {\n    return;\n  }\n\n  // get instruction data\n  const decoded = bs58.decode(instruction.data);\n\n  const programId = getAccountByIndex(\n    [instruction.programIdIndex],\n    accountKeys,\n    0,\n  );\n  if (!programId) {\n    return null;\n  }\n\n  try {\n    if (programId.equals(SystemProgram.programId)) {\n      console.log('[' + index + '] Handled as system instruction');\n      return handleSystemInstruction(publicKey, instruction, accountKeys);\n    } else if (programId.equals(StakeProgram.programId)) {\n      console.log('[' + index + '] Handled as stake instruction');\n      return handleStakeInstruction(publicKey, instruction, accountKeys);\n    } else if (programId.equals(TOKEN_PROGRAM_ID)) {\n      console.log('[' + index + '] Handled as token instruction');\n      return handleTokenInstruction(publicKey, instruction, accountKeys);\n    } else if (\n      MARKETS.some(\n        (market) => market.programId && market.programId.equals(programId),\n      )\n    ) {\n      console.log('[' + index + '] Handled as dex instruction');\n      let decodedInstruction = decodeInstruction(decoded);\n      return await handleDexInstruction(\n        connection,\n        instruction,\n        accountKeys,\n        decodedInstruction,\n      );\n    } else if (programId.equals(RAYDIUM_STAKE_PROGRAM_ID)) {\n      console.log('[' + index + '] Handled as raydium stake instruction');\n      // @ts-ignore\n      const decodedInstruction = decodeStakeInstruction(decoded);\n      return await handleRayStakeInstruction(\n        connection,\n        instruction,\n        accountKeys,\n        decodedInstruction,\n      );\n    } else if (programId.equals(RAYDIUM_LP_PROGRAM_ID)) {\n      console.log('[' + index + '] Handled as raydium lp instruction');\n      // @ts-ignore\n      const decodedInstruction = decodeLpInstruction(decoded);\n      return await handleRayLpInstruction(\n        connection,\n        instruction,\n        accountKeys,\n        decodedInstruction,\n      );\n    } else if (programId.equals(MANGO_PROGRAM_ID) || programId.equals(MANGO_PROGRAM_ID_V2)) {\n      console.log('[' + index + '] Handled as mango markets instruction');\n      // @ts-ignore\n      let decodedInstruction = decodeMangoInstruction(decoded);\n      return await handleMangoInstruction(\n        connection,\n        instruction,\n        accountKeys,\n        decodedInstruction,\n      );\n    } else {\n      return {\n        type: 'Unknown',\n        accountMetas: instruction.accounts.map((index) => ({\n          publicKey: accountKeys[index],\n          isWritable: transactionMessage.isAccountWritable(index),\n        })),\n        programId,\n      };\n    }\n  } catch (e) {\n    console.log(`Failed to decode instruction: ${e}`);\n  }\n\n  // all decodings failed\n  console.log('[' + index + '] Failed, data: ' + JSON.stringify(decoded));\n\n  return;\n};\n\nconst handleMangoInstruction = async (\n  connection,\n  instruction,\n  accountKeys,\n  decodedInstruction,\n) => {\n  // TODO\n  return {\n    type: 'mango',\n  };\n};\n\nconst handleRayStakeInstruction = async (\n  connection,\n  instruction,\n  accountKeys,\n  decodedInstruction,\n) => {\n  // TODO\n  return {\n    type: 'raydium',\n  };\n};\n\nconst handleRayLpInstruction = async (\n  connection,\n  instruction,\n  accountKeys,\n  decodedInstruction,\n) => {\n  // TODO\n  return {\n    type: 'raydium',\n  };\n};\n\nconst decodeMangoInstruction = () => {\n  // TODO\n  return undefined;\n};\n\nconst decodeStakeInstruction = () => {\n  // TODO\n  return undefined;\n};\n\nconst decodeLpInstruction = () => {\n  // TODO\n  return undefined;\n};\n\nconst handleDexInstruction = async (\n  connection,\n  instruction,\n  accountKeys,\n  decodedInstruction,\n) => {\n  if (!decodedInstruction || Object.keys(decodedInstruction).length > 1) {\n    return;\n  }\n\n  const { accounts, programIdIndex } = instruction;\n\n  // get market info\n  const marketInfo =\n    accountKeys &&\n    MARKETS.find(\n      (market) =>\n        accountKeys.findIndex((accountKey) =>\n          accountKey.equals(market.address),\n        ) > -1,\n    );\n\n  // get market\n  let market, programIdAddress;\n  try {\n    const marketAddress =\n      marketInfo?.address || getAccountByIndex(accounts, accountKeys, 0);\n    programIdAddress =\n      marketInfo?.programId ||\n      getAccountByIndex([programIdIndex], accountKeys, 0);\n    const strAddress = marketAddress.toBase58();\n    const now = new Date().getTime();\n    if (\n      !(\n        connection === marketCacheConnection &&\n        strAddress in marketCache &&\n        now - marketCache[strAddress].ts < cacheDuration\n      )\n    ) {\n      marketCacheConnection = connection;\n      console.log('Loading market', strAddress);\n      marketCache[strAddress] = {\n        market: await Market.load(\n          connection,\n          marketAddress,\n          {},\n          programIdAddress,\n        ),\n        ts: now,\n      };\n    }\n    market = marketCache[strAddress].market;\n  } catch (e) {\n    console.log('Error loading market: ' + e.message);\n  }\n\n  // get data\n  const type = Object.keys(decodedInstruction)[0];\n  let data = decodedInstruction[type];\n  if (type === 'settleFunds') {\n    const settleFundsData = getSettleFundsData(accounts, accountKeys);\n    if (!settleFundsData) {\n      return;\n    } else {\n      data = { ...data, ...settleFundsData };\n    }\n  } else if (type === 'newOrder') {\n    const newOrderData = getNewOrderData(accounts, accountKeys);\n    data = { ...data, ...newOrderData };\n  } else if (type === 'newOrderV3') {\n    const newOrderData = getNewOrderV3Data(accounts, accountKeys);\n    data = { ...data, ...newOrderData };\n  }\n  return {\n    type,\n    data,\n    market,\n    marketInfo,\n  };\n};\n\nconst handleSystemInstruction = (publicKey, instruction, accountKeys) => {\n  const { programIdIndex, accounts, data } = instruction;\n  if (!programIdIndex || !accounts || !data) {\n    return;\n  }\n\n  // construct system instruction\n  const systemInstruction = {\n    programId: accountKeys[programIdIndex],\n    keys: accounts.map((accountIndex) => ({\n      pubkey: accountKeys[accountIndex],\n    })),\n    data: bs58.decode(data),\n  };\n\n  // get layout\n  let decoded;\n  const type = SystemInstruction.decodeInstructionType(systemInstruction);\n  switch (type) {\n    case 'Create':\n      decoded = SystemInstruction.decodeCreateAccount(systemInstruction);\n      break;\n    case 'CreateWithSeed':\n      decoded = SystemInstruction.decodeCreateWithSeed(systemInstruction);\n      break;\n    case 'Allocate':\n      decoded = SystemInstruction.decodeAllocate(systemInstruction);\n      break;\n    case 'AllocateWithSeed':\n      decoded = SystemInstruction.decodeAllocateWithSeed(systemInstruction);\n      break;\n    case 'Assign':\n      decoded = SystemInstruction.decodeAssign(systemInstruction);\n      break;\n    case 'AssignWithSeed':\n      decoded = SystemInstruction.decodeAssignWithSeed(systemInstruction);\n      break;\n    case 'Transfer':\n      decoded = SystemInstruction.decodeTransfer(systemInstruction);\n      break;\n    case 'AdvanceNonceAccount':\n      decoded = SystemInstruction.decodeNonceAdvance(systemInstruction);\n      break;\n    case 'WithdrawNonceAccount':\n      decoded = SystemInstruction.decodeNonceWithdraw(systemInstruction);\n      break;\n    case 'InitializeNonceAccount':\n      decoded = SystemInstruction.decodeNonceInitialize(systemInstruction);\n      break;\n    case 'AuthorizeNonceAccount':\n      decoded = SystemInstruction.decodeNonceAuthorize(systemInstruction);\n      break;\n    default:\n      return;\n  }\n\n  if (\n    !decoded ||\n    (decoded.fromPubkey && !publicKey.equals(decoded.fromPubkey))\n  ) {\n    return;\n  }\n\n  return {\n    type: 'system' + type,\n    data: decoded,\n  };\n};\n\nconst handleStakeInstruction = (publicKey, instruction, accountKeys) => {\n  const { programIdIndex, accounts, data } = instruction;\n  if (!programIdIndex || !accounts || !data) {\n    return;\n  }\n\n  // construct stake instruction\n  const stakeInstruction = {\n    programId: accountKeys[programIdIndex],\n    keys: accounts.map((accountIndex) => ({\n      pubkey: accountKeys[accountIndex],\n    })),\n    data: bs58.decode(data),\n  };\n\n  let decoded;\n  const type = StakeInstruction.decodeInstructionType(stakeInstruction);\n  switch (type) {\n    case 'AuthorizeWithSeed':\n      decoded = StakeInstruction.decodeAuthorizeWithSeed(stakeInstruction);\n      break;\n    case 'Authorize':\n      decoded = StakeInstruction.decodeAuthorize(stakeInstruction);\n      break;\n    case 'Deactivate':\n      decoded = StakeInstruction.decodeDeactivate(stakeInstruction);\n      break;\n    case 'Delegate':\n      decoded = StakeInstruction.decodeDelegate(stakeInstruction);\n      break;\n    case 'Initialize':\n      decoded = StakeInstruction.decodeInitialize(stakeInstruction);\n      // Lockup inactive if all zeroes\n      const lockup = decoded.lockup;\n      if (lockup && lockup.unixTimestamp === 0 && lockup.epoch === 0 && lockup.custodian.equals(PublicKey.default)) {\n        decoded.lockup = 'Inactive';\n      }\n      else {\n        decoded.lockup = `unixTimestamp: ${lockup.unixTimestamp}, custodian: ${lockup.epoch}, custodian: ${lockup.custodian.toBase58()}`;\n      }\n      // flatten authorized to allow address render\n      decoded.authorizedStaker = decoded.authorized.staker\n      decoded.authorizedWithdrawer = decoded.authorized.withdrawer\n      delete decoded.authorized\n      break;\n    case 'Split':\n      decoded = StakeInstruction.decodeSplit(stakeInstruction);\n      break;\n    case 'Withdraw':\n      decoded = StakeInstruction.decodeWithdraw(stakeInstruction);\n      break;\n    default:\n      return;\n  }\n\n  if (\n    !decoded ||\n    (decoded.fromPubkey && !publicKey.equals(decoded.fromPubkey))\n  ) {\n    return;\n  }\n\n  return {\n    type: 'stake' + type,\n    data: decoded,\n  };\n};\n\nconst handleTokenInstruction = (\n  publicKey: PublicKey,\n  instruction,\n  accountKeys,\n) => {\n  const { programIdIndex, accounts, data } = instruction;\n  if (!programIdIndex || !accounts || !data) {\n    return;\n  }\n\n  // construct token instruction\n  const tokenInstruction = {\n    programId: accountKeys[programIdIndex],\n    keys: accounts.map((accountIndex) => ({\n      pubkey: accountKeys[accountIndex],\n    })),\n    data: bs58.decode(data),\n  };\n\n  let decoded = decodeTokenInstruction(tokenInstruction);\n\n  return {\n    type: decoded.type,\n    data: decoded.params,\n  }\n};\n\nconst getNewOrderData = (accounts, accountKeys) => {\n  const openOrdersPubkey = getAccountByIndex(\n    accounts,\n    accountKeys,\n    NEW_ORDER_OPEN_ORDERS_INDEX,\n  );\n  const ownerPubkey = getAccountByIndex(\n    accounts,\n    accountKeys,\n    NEW_ORDER_OWNER_INDEX,\n  );\n  return { openOrdersPubkey, ownerPubkey };\n};\n\nconst getNewOrderV3Data = (accounts, accountKeys) => {\n  const openOrdersPubkey = getAccountByIndex(\n    accounts,\n    accountKeys,\n    NEW_ORDER_V3_OPEN_ORDERS_INDEX,\n  );\n  const ownerPubkey = getAccountByIndex(\n    accounts,\n    accountKeys,\n    NEW_ORDER_V3_OWNER_INDEX,\n  );\n  return { openOrdersPubkey, ownerPubkey };\n};\n\nconst getSettleFundsData = (accounts, accountKeys) => {\n  const basePubkey = getAccountByIndex(\n    accounts,\n    accountKeys,\n    SETTLE_FUNDS_BASE_WALLET_INDEX,\n  );\n\n  const quotePubkey = getAccountByIndex(\n    accounts,\n    accountKeys,\n    SETTLE_FUNDS_QUOTE_WALLET_INDEX,\n  );\n\n  if (!basePubkey || !quotePubkey) {\n    return;\n  }\n\n  return { basePubkey, quotePubkey };\n};\n\nconst getAccountByIndex = (accounts, accountKeys, accountIndex) => {\n  const index = accounts.length > accountIndex && accounts[accountIndex];\n  return accountKeys?.length > index && accountKeys[index];\n};\n"]},"metadata":{},"sourceType":"module"}