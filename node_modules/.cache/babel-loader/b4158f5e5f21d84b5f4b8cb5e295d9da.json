{"ast":null,"code":"import Transport from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId, ledgerUSBVendorId } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport { TransportOpenUserCancelled, DisconnectedDeviceDuringOperation, DisconnectedDevice, TransportError } from \"@ledgerhq/errors\";\nconst ledgerDevices = [{\n  vendorId: ledgerUSBVendorId\n}];\n\nconst isSupported = () => Promise.resolve(!!(global.navigator && global.navigator.hid));\n\nconst getHID = () => {\n  // $FlowFixMe\n  const {\n    hid\n  } = navigator;\n  if (!hid) throw new TransportError(\"navigator.hid is not supported\", \"HIDNotSupported\");\n  return hid;\n};\n\nasync function requestLedgerDevices() {\n  const device = await getHID().requestDevice({\n    filters: ledgerDevices\n  });\n  if (Array.isArray(device)) return device;\n  return [device];\n}\n\nasync function getLedgerDevices() {\n  const devices = await getHID().getDevices();\n  return devices.filter(d => d.vendorId === ledgerUSBVendorId);\n}\n\nasync function getFirstLedgerDevice() {\n  const existingDevices = await getLedgerDevices();\n  if (existingDevices.length > 0) return existingDevices[0];\n  const devices = await requestLedgerDevices();\n  return devices[0];\n}\n/**\n * WebHID Transport implementation\n * @example\n * import TransportWebHID from \"@ledgerhq/hw-transport-webhid\";\n * ...\n * TransportWebHID.create().then(transport => ...)\n */\n\n\nexport default class TransportWebHID extends Transport {\n  constructor(device) {\n    super();\n    this.device = void 0;\n    this.deviceModel = void 0;\n    this.channel = Math.floor(Math.random() * 0xffff);\n    this.packetSize = 64;\n    this.inputs = [];\n    this.inputCallback = void 0;\n\n    this.read = () => {\n      if (this.inputs.length) {\n        return Promise.resolve(this.inputs.shift());\n      }\n\n      return new Promise(success => {\n        this.inputCallback = success;\n      });\n    };\n\n    this.onInputReport = e => {\n      const buffer = Buffer.from(e.data.buffer);\n\n      if (this.inputCallback) {\n        this.inputCallback(buffer);\n        this.inputCallback = null;\n      } else {\n        this.inputs.push(buffer);\n      }\n    };\n\n    this._disconnectEmitted = false;\n\n    this._emitDisconnect = e => {\n      if (this._disconnectEmitted) return;\n      this._disconnectEmitted = true;\n      this.emit(\"disconnect\", e);\n    };\n\n    this.exchange = apdu => this.exchangeAtomicImpl(async () => {\n      const {\n        channel,\n        packetSize\n      } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n      const framing = hidFraming(channel, packetSize); // Write...\n\n      const blocks = framing.makeBlocks(apdu);\n\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.sendReport(0, blocks[i]);\n      } // Read...\n\n\n      let result;\n      let acc;\n\n      while (!(result = framing.getReducedResult(acc))) {\n        const buffer = await this.read();\n        acc = framing.reduceResponse(acc, buffer);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    }).catch(e => {\n      if (e && e.message && e.message.includes(\"write\")) {\n        this._emitDisconnect(e);\n\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n\n      throw e;\n    });\n\n    this.device = device;\n    this.deviceModel = identifyUSBProductId(device.productId);\n    device.addEventListener(\"inputreport\", this.onInputReport);\n  }\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n\n\n  static async request() {\n    const [device] = await requestLedgerDevices();\n    return TransportWebHID.open(device);\n  }\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n\n\n  static async openConnected() {\n    const devices = await getLedgerDevices();\n    if (devices.length === 0) return null;\n    return TransportWebHID.open(devices[0]);\n  }\n  /**\n   * Create a Ledger transport with a HIDDevice\n   */\n\n\n  static async open(device) {\n    await device.open();\n    const transport = new TransportWebHID(device);\n\n    const onDisconnect = e => {\n      if (device === e.device) {\n        getHID().removeEventListener(\"disconnect\", onDisconnect);\n\n        transport._emitDisconnect(new DisconnectedDevice());\n      }\n    };\n\n    getHID().addEventListener(\"disconnect\", onDisconnect);\n    return transport;\n  }\n  /**\n   * Release the transport device\n   */\n\n\n  async close() {\n    await this.exchangeBusyPromise;\n    this.device.removeEventListener(\"inputreport\", this.onInputReport);\n    await this.device.close();\n  }\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n\n\n  setScrambleKey() {}\n\n}\nTransportWebHID.isSupported = isSupported;\nTransportWebHID.list = getLedgerDevices;\n\nTransportWebHID.listen = observer => {\n  let unsubscribed = false;\n  getFirstLedgerDevice().then(device => {\n    if (!device) {\n      observer.error(new TransportOpenUserCancelled(\"Access denied to use Ledger device\"));\n    } else if (!unsubscribed) {\n      const deviceModel = identifyUSBProductId(device.productId);\n      observer.next({\n        type: \"add\",\n        descriptor: device,\n        deviceModel\n      });\n      observer.complete();\n    }\n  }, error => {\n    observer.error(new TransportOpenUserCancelled(error.message));\n  });\n\n  function unsubscribe() {\n    unsubscribed = true;\n  }\n\n  return {\n    unsubscribe\n  };\n};","map":{"version":3,"sources":["../src/TransportWebHID.js"],"names":["ledgerDevices","vendorId","ledgerUSBVendorId","isSupported","Promise","global","getHID","hid","device","filters","Array","devices","d","existingDevices","getLedgerDevices","requestLedgerDevices","TransportWebHID","deviceModel","channel","Math","packetSize","constructor","identifyUSBProductId","success","e","buffer","Buffer","list","listen","observer","unsubscribed","getFirstLedgerDevice","type","descriptor","error","unsubscribe","request","openConnected","open","transport","onDisconnect","close","apdu","log","framing","hidFraming","blocks","i","result","acc","setScrambleKey"],"mappings":"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","sourcesContent":["//@flow\nimport Transport from \"@ledgerhq/hw-transport\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription,\n} from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId, ledgerUSBVendorId } from \"@ledgerhq/devices\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport {\n  TransportOpenUserCancelled,\n  DisconnectedDeviceDuringOperation,\n  DisconnectedDevice,\n  TransportError,\n} from \"@ledgerhq/errors\";\n\nconst ledgerDevices = [{ vendorId: ledgerUSBVendorId }];\n\nconst isSupported = () =>\n  Promise.resolve(!!(global.navigator && global.navigator.hid));\n\nconst getHID = (): HID => {\n  // $FlowFixMe\n  const { hid } = navigator;\n  if (!hid)\n    throw new TransportError(\n      \"navigator.hid is not supported\",\n      \"HIDNotSupported\"\n    );\n  return hid;\n};\n\nasync function requestLedgerDevices(): Promise<HIDDevice[]> {\n  const device = await getHID().requestDevice({ filters: ledgerDevices });\n  if (Array.isArray(device)) return device;\n  return [device];\n}\n\nasync function getLedgerDevices(): Promise<HIDDevice[]> {\n  const devices = await getHID().getDevices();\n  return devices.filter((d) => d.vendorId === ledgerUSBVendorId);\n}\n\nasync function getFirstLedgerDevice(): Promise<HIDDevice> {\n  const existingDevices = await getLedgerDevices();\n  if (existingDevices.length > 0) return existingDevices[0];\n  const devices = await requestLedgerDevices();\n  return devices[0];\n}\n\n/**\n * WebHID Transport implementation\n * @example\n * import TransportWebHID from \"@ledgerhq/hw-transport-webhid\";\n * ...\n * TransportWebHID.create().then(transport => ...)\n */\nexport default class TransportWebHID extends Transport<HIDDevice> {\n  device: HIDDevice;\n  deviceModel: ?DeviceModel;\n  channel = Math.floor(Math.random() * 0xffff);\n  packetSize = 64;\n\n  constructor(device: HIDDevice) {\n    super();\n    this.device = device;\n    this.deviceModel = identifyUSBProductId(device.productId);\n    device.addEventListener(\"inputreport\", this.onInputReport);\n  }\n\n  inputs = [];\n  inputCallback: ?(Buffer) => void;\n\n  read = (): Promise<Buffer> => {\n    if (this.inputs.length) {\n      return Promise.resolve(this.inputs.shift());\n    }\n    return new Promise((success) => {\n      this.inputCallback = success;\n    });\n  };\n\n  onInputReport = (e: InputReportEvent) => {\n    const buffer = Buffer.from(e.data.buffer);\n    if (this.inputCallback) {\n      this.inputCallback(buffer);\n      this.inputCallback = null;\n    } else {\n      this.inputs.push(buffer);\n    }\n  };\n\n  /**\n   * Check if WebUSB transport is supported.\n   */\n  static isSupported = isSupported;\n\n  /**\n   * List the WebUSB devices that was previously authorized by the user.\n   */\n  static list = getLedgerDevices;\n\n  /**\n   * Actively listen to WebUSB devices and emit ONE device\n   * that was either accepted before, if not it will trigger the native permission UI.\n   *\n   * Important: it must be called in the context of a UI click!\n   */\n  static listen = (\n    observer: Observer<DescriptorEvent<HIDDevice>>\n  ): Subscription => {\n    let unsubscribed = false;\n    getFirstLedgerDevice().then(\n      (device) => {\n        if (!device) {\n          observer.error(\n            new TransportOpenUserCancelled(\"Access denied to use Ledger device\")\n          );\n        } else if (!unsubscribed) {\n          const deviceModel = identifyUSBProductId(device.productId);\n          observer.next({ type: \"add\", descriptor: device, deviceModel });\n          observer.complete();\n        }\n      },\n      (error) => {\n        observer.error(new TransportOpenUserCancelled(error.message));\n      }\n    );\n    function unsubscribe() {\n      unsubscribed = true;\n    }\n    return { unsubscribe };\n  };\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n  static async request() {\n    const [device] = await requestLedgerDevices();\n    return TransportWebHID.open(device);\n  }\n\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n  static async openConnected() {\n    const devices = await getLedgerDevices();\n    if (devices.length === 0) return null;\n    return TransportWebHID.open(devices[0]);\n  }\n\n  /**\n   * Create a Ledger transport with a HIDDevice\n   */\n  static async open(device: HIDDevice) {\n    await device.open();\n    const transport = new TransportWebHID(device);\n    const onDisconnect = (e) => {\n      if (device === e.device) {\n        getHID().removeEventListener(\"disconnect\", onDisconnect);\n        transport._emitDisconnect(new DisconnectedDevice());\n      }\n    };\n    getHID().addEventListener(\"disconnect\", onDisconnect);\n    return transport;\n  }\n\n  _disconnectEmitted = false;\n  _emitDisconnect = (e: Error) => {\n    if (this._disconnectEmitted) return;\n    this._disconnectEmitted = true;\n    this.emit(\"disconnect\", e);\n  };\n\n  /**\n   * Release the transport device\n   */\n  async close(): Promise<void> {\n    await this.exchangeBusyPromise;\n    this.device.removeEventListener(\"inputreport\", this.onInputReport);\n    await this.device.close();\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  exchange = (apdu: Buffer): Promise<Buffer> =>\n    this.exchangeAtomicImpl(async () => {\n      const { channel, packetSize } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n\n      const framing = hidFraming(channel, packetSize);\n\n      // Write...\n      const blocks = framing.makeBlocks(apdu);\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.sendReport(0, blocks[i]);\n      }\n\n      // Read...\n      let result;\n      let acc;\n      while (!(result = framing.getReducedResult(acc))) {\n        const buffer = await this.read();\n        acc = framing.reduceResponse(acc, buffer);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    }).catch((e) => {\n      if (e && e.message && e.message.includes(\"write\")) {\n        this._emitDisconnect(e);\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n      throw e;\n    });\n\n  setScrambleKey() {}\n}\n"]},"metadata":{},"sourceType":"module"}