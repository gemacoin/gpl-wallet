{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { PublicKey } from '@solana/web3.js';\nimport { getTwitterRegistry, getHashedName, getNameAccountKey, NameRegistryState, getFilteredProgramAccounts, NAME_PROGRAM_ID } from '@bonfida/spl-name-service';\nimport { useConnection } from '../connection';\nimport { useWallet } from '../wallet';\nimport BN from 'bn.js';\nimport { useAsyncData } from '../fetch-loop';\nimport tuple from 'immutable-tuple'; // Address of the GEMA TLD\n\nexport const SOL_TLD_AUTHORITY = new PublicKey('58PwtjSDuFHuUkYjH9BYnnQKHfwo9reZhC2zMJv9JPkx');\nexport const PROGRAM_ID = new PublicKey('jCebN34bUfdeUYJT13J1yG16XWQpt5PDx6Mse9GUqhR');\nexport const resolveTwitterHandle = async (connection, twitterHandle) => {\n  try {\n    const registry = await getTwitterRegistry(connection, twitterHandle);\n    return registry.owner.toBase58();\n  } catch (err) {\n    console.warn(`err`);\n    return undefined;\n  }\n};\nexport const resolveDomainName = async (connection, domainName) => {\n  let hashedDomainName = await getHashedName(domainName);\n  let inputDomainKey = await getNameAccountKey(hashedDomainName, undefined, SOL_TLD_AUTHORITY);\n\n  try {\n    const registry = await NameRegistryState.retrieve(connection, inputDomainKey);\n    return registry.owner.toBase58();\n  } catch (err) {\n    console.warn(err);\n    return undefined;\n  }\n};\nexport async function findOwnedNameAccountsForUser(connection, userAccount) {\n  const filters = [{\n    memcmp: {\n      offset: 32,\n      bytes: userAccount.toBase58()\n    }\n  }];\n  const accounts = await getFilteredProgramAccounts(connection, NAME_PROGRAM_ID, filters);\n  return accounts.map(a => a.publicKey);\n}\nexport async function performReverseLookup(connection, nameAccount) {\n  let [centralState] = await PublicKey.findProgramAddress([PROGRAM_ID.toBuffer()], PROGRAM_ID);\n  let hashedReverseLookup = await getHashedName(nameAccount.toBase58());\n  let reverseLookupAccount = await getNameAccountKey(hashedReverseLookup, centralState);\n  let name = await NameRegistryState.retrieve(connection, reverseLookupAccount);\n\n  if (!name.data) {\n    throw new Error('Could not retrieve name data');\n  }\n\n  let nameLength = new BN(name.data.slice(0, 4), 'le').toNumber();\n  return name.data.slice(4, 4 + nameLength).toString();\n}\nexport const useUserDomains = () => {\n  _s();\n\n  var _wallet$publicKey;\n\n  const wallet = useWallet();\n  const connection = useConnection();\n\n  const fn = async () => {\n    const domains = await findOwnedNameAccountsForUser(connection, wallet.publicKey);\n    let names = [];\n\n    const fn = async d => {\n      try {\n        const name = await performReverseLookup(connection, d);\n        names.push({\n          name: name,\n          nameKey: d\n        });\n      } catch (err) {\n        console.log(`Passing account ${d.toBase58()} - err ${err}`);\n      }\n    };\n\n    const promises = domains.map(d => fn(d));\n    await Promise.allSettled(promises);\n    return names.sort((a, b) => {\n      return a.name.localeCompare(b.name);\n    });\n  };\n\n  return useAsyncData(fn, tuple('useUserDomain', wallet === null || wallet === void 0 ? void 0 : (_wallet$publicKey = wallet.publicKey) === null || _wallet$publicKey === void 0 ? void 0 : _wallet$publicKey.toBase58()));\n};\n\n_s(useUserDomains, \"Oy0D2UitdjwjzE63KE6Xgn8P95Y=\", false, function () {\n  return [useWallet, useConnection, useAsyncData];\n});","map":{"version":3,"sources":["/home/imentus/spl-token-wallet/src/utils/name-service/index.ts"],"names":["PublicKey","getTwitterRegistry","getHashedName","getNameAccountKey","NameRegistryState","getFilteredProgramAccounts","NAME_PROGRAM_ID","useConnection","useWallet","BN","useAsyncData","tuple","SOL_TLD_AUTHORITY","PROGRAM_ID","resolveTwitterHandle","connection","twitterHandle","registry","owner","toBase58","err","console","warn","undefined","resolveDomainName","domainName","hashedDomainName","inputDomainKey","retrieve","findOwnedNameAccountsForUser","userAccount","filters","memcmp","offset","bytes","accounts","map","a","publicKey","performReverseLookup","nameAccount","centralState","findProgramAddress","toBuffer","hashedReverseLookup","reverseLookupAccount","name","data","Error","nameLength","slice","toNumber","toString","useUserDomains","wallet","fn","domains","names","d","push","nameKey","log","promises","Promise","allSettled","sort","b","localeCompare"],"mappings":"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","sourcesContent":["import { PublicKey, Connection } from '@solana/web3.js';\nimport {\n  getTwitterRegistry,\n  getHashedName,\n  getNameAccountKey,\n  NameRegistryState,\n  getFilteredProgramAccounts,\n  NAME_PROGRAM_ID,\n} from '@bonfida/spl-name-service';\nimport { useConnection } from '../connection';\nimport { useWallet } from '../wallet';\nimport BN from 'bn.js';\nimport { useAsyncData } from '../fetch-loop';\nimport tuple from 'immutable-tuple';\n\n// Address of the GEMA TLD\nexport const SOL_TLD_AUTHORITY = new PublicKey(\n  '58PwtjSDuFHuUkYjH9BYnnQKHfwo9reZhC2zMJv9JPkx',\n);\n\nexport const PROGRAM_ID = new PublicKey(\n  'jCebN34bUfdeUYJT13J1yG16XWQpt5PDx6Mse9GUqhR',\n);\n\nexport const resolveTwitterHandle = async (\n  connection: Connection,\n  twitterHandle: string,\n): Promise<string | undefined> => {\n  try {\n    const registry = await getTwitterRegistry(connection, twitterHandle);\n    return registry.owner.toBase58();\n  } catch (err) {\n    console.warn(`err`);\n    return undefined;\n  }\n};\n\nexport const resolveDomainName = async (\n  connection: Connection,\n  domainName: string,\n): Promise<string | undefined> => {\n  let hashedDomainName = await getHashedName(domainName);\n  let inputDomainKey = await getNameAccountKey(\n    hashedDomainName,\n    undefined,\n    SOL_TLD_AUTHORITY,\n  );\n  try {\n    const registry = await NameRegistryState.retrieve(\n      connection,\n      inputDomainKey,\n    );\n    return registry.owner.toBase58();\n  } catch (err) {\n    console.warn(err);\n    return undefined;\n  }\n};\n\nexport async function findOwnedNameAccountsForUser(\n  connection: Connection,\n  userAccount: PublicKey,\n): Promise<PublicKey[]> {\n  const filters = [\n    {\n      memcmp: {\n        offset: 32,\n        bytes: userAccount.toBase58(),\n      },\n    },\n  ];\n  const accounts = await getFilteredProgramAccounts(\n    connection,\n    NAME_PROGRAM_ID,\n    filters,\n  );\n  return accounts.map((a) => a.publicKey);\n}\n\nexport async function performReverseLookup(\n  connection: Connection,\n  nameAccount: PublicKey,\n): Promise<string> {\n  let [centralState] = await PublicKey.findProgramAddress(\n    [PROGRAM_ID.toBuffer()],\n    PROGRAM_ID,\n  );\n  let hashedReverseLookup = await getHashedName(nameAccount.toBase58());\n  let reverseLookupAccount = await getNameAccountKey(\n    hashedReverseLookup,\n    centralState,\n  );\n\n  let name = await NameRegistryState.retrieve(connection, reverseLookupAccount);\n  if (!name.data) {\n    throw new Error('Could not retrieve name data');\n  }\n  let nameLength = new BN(name.data.slice(0, 4), 'le').toNumber();\n  return name.data.slice(4, 4 + nameLength).toString();\n}\n\nexport const useUserDomains = () => {\n  const wallet = useWallet();\n  const connection = useConnection();\n  const fn = async () => {\n    const domains = await findOwnedNameAccountsForUser(\n      connection,\n      wallet.publicKey,\n    );\n    let names: { name: string; nameKey: PublicKey }[] = [];\n    const fn = async (d) => {\n      try {\n        const name = await performReverseLookup(connection, d);\n        names.push({ name: name, nameKey: d });\n      } catch (err) {\n        console.log(`Passing account ${d.toBase58()} - err ${err}`);\n      }\n    };\n    const promises = domains.map((d) => fn(d));\n    await Promise.allSettled(promises);\n    return names.sort((a, b) => {\n      return a.name.localeCompare(b.name);\n    });\n  };\n  return useAsyncData(\n    fn,\n    tuple('useUserDomain', wallet?.publicKey?.toBase58()),\n  );\n};\n"]},"metadata":{},"sourceType":"module"}