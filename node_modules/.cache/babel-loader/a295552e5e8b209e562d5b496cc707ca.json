{"ast":null,"code":"/**\n * Simple asynchronous tool for saving my life.\n */\n\n/**\n * A wrapper function create a `Chain` instance at the same \n * time initializes the `queue` with a serial of arguments. \n */\nmodule.exports = function () {\n  var s = new Chain();\n  return s.__init.apply(s, arguments);\n};\n/** \n * Chain constructor.\n * @api pivate\n */\n\n\nfunction Chain() {\n  this.queue = [];\n\n  this.onend = function (err) {};\n\n  this.pass = true;\n}\n/**\n * Trying to Initialize the `queue` with a serial of arguments. \n *\n * @api private\n */\n\n\nChain.prototype.__init = function () {\n  this.queue = [].slice.call(arguments);\n  return this;\n};\n/**\n * Add a `job` or an array of `jobs` into the Chain.\n * A `job` is defined by a function. \n *\n * @param {Function|Array} a function or an array of functions \n * @return {Chain}\n * @api public\n */\n\n\nChain.prototype.add = function () {\n  var jobs = [].slice.call(arguments);\n  jobs.forEach(function (job) {\n    this.queue.push.apply(this.queue, Array.isArray(job) ? job : [job]);\n  }.bind(this));\n  return this;\n};\n/**\n * The iterator of the Chain. When it reaches end then call \n * call the callback function.\n * \n * @return {Chain}\n * @api public\n */\n\n\nChain.prototype.next = function () {\n  if (!this.pass) return this;\n\n  if (this.queue.length) {\n    this.queue.shift().call();\n  } else {\n    this.onend();\n  }\n\n  return this;\n};\n/**\n * Terminate the chain.\n * \n * @return {Chain}\n * @api public\n */\n\n\nChain.prototype.stop = function () {\n  this.pass = false;\n  this.onend.apply(this, arguments);\n  return this;\n};\n/**\n * Start iterating through the Chain and ends with the  \n * given callback.\n * \n * @param {Function} end callback\n * @return {Chain} \n * @api public\n */\n\n\nChain.prototype.traverse = function (fn) {\n  fn && fn.call && fn.apply && (this.onend = fn);\n  this.next();\n  return this;\n};","map":{"version":3,"sources":["/home/imentus/spl-token-wallet/node_modules/traverse-chain/index.js"],"names":["module","exports","s","Chain","__init","apply","arguments","queue","onend","err","pass","prototype","slice","call","add","jobs","forEach","job","push","Array","isArray","bind","next","length","shift","stop","traverse","fn"],"mappings":"AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACAA,MAAM,CAACC,OAAP,GAAiB,YAAW;AAC1B,MAAIC,CAAC,GAAG,IAAIC,KAAJ,EAAR;AACA,SAAOD,CAAC,CAACE,MAAF,CAASC,KAAT,CAAeH,CAAf,EAAkBI,SAAlB,CAAP;AACD,CAHD;AAMA;AACA;AACA;AACA;;;AACA,SAASH,KAAT,GAAiB;AACf,OAAKI,KAAL,GAAa,EAAb;;AACA,OAAKC,KAAL,GAAa,UAASC,GAAT,EAAc,CAAE,CAA7B;;AACA,OAAKC,IAAL,GAAY,IAAZ;AACD;AAGD;AACA;AACA;AACA;AACA;;;AACAP,KAAK,CAACQ,SAAN,CAAgBP,MAAhB,GAAyB,YAAW;AAClC,OAAKG,KAAL,GAAa,GAAGK,KAAH,CAASC,IAAT,CAAcP,SAAd,CAAb;AACA,SAAO,IAAP;AACD,CAHD;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAH,KAAK,CAACQ,SAAN,CAAgBG,GAAhB,GAAsB,YAAW;AAC/B,MAAIC,IAAI,GAAG,GAAGH,KAAH,CAASC,IAAT,CAAcP,SAAd,CAAX;AACAS,EAAAA,IAAI,CAACC,OAAL,CACG,UAASC,GAAT,EAAc;AACb,SAAKV,KAAL,CAAWW,IAAX,CAAgBb,KAAhB,CACE,KAAKE,KADP,EACcY,KAAK,CAACC,OAAN,CAAcH,GAAd,IAAqBA,GAArB,GAA2B,CAACA,GAAD,CADzC;AAGD,GAJD,CAIGI,IAJH,CAIQ,IAJR,CADF;AAOA,SAAO,IAAP;AACD,CAVD;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAlB,KAAK,CAACQ,SAAN,CAAgBW,IAAhB,GAAuB,YAAW;AAChC,MAAI,CAAC,KAAKZ,IAAV,EAAgB,OAAO,IAAP;;AAChB,MAAI,KAAKH,KAAL,CAAWgB,MAAf,EAAuB;AACrB,SAAKhB,KAAL,CAAWiB,KAAX,GAAmBX,IAAnB;AACD,GAFD,MAEO;AACL,SAAKL,KAAL;AACD;;AACD,SAAO,IAAP;AACD,CARD;AAWA;AACA;AACA;AACA;AACA;AACA;;;AACAL,KAAK,CAACQ,SAAN,CAAgBc,IAAhB,GAAuB,YAAW;AAChC,OAAKf,IAAL,GAAY,KAAZ;AACA,OAAKF,KAAL,CAAWH,KAAX,CAAiB,IAAjB,EAAuBC,SAAvB;AACA,SAAO,IAAP;AACD,CAJD;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAH,KAAK,CAACQ,SAAN,CAAgBe,QAAhB,GAA2B,UAASC,EAAT,EAAa;AACtCA,EAAAA,EAAE,IAAIA,EAAE,CAACd,IAAT,IAAiBc,EAAE,CAACtB,KAApB,KAA8B,KAAKG,KAAL,GAAamB,EAA3C;AACA,OAAKL,IAAL;AACA,SAAO,IAAP;AACD,CAJD","sourcesContent":["/**\n * Simple asynchronous tool for saving my life.\n */\n\n/**\n * A wrapper function create a `Chain` instance at the same \n * time initializes the `queue` with a serial of arguments. \n */\nmodule.exports = function() {\n  var s = new Chain();\n  return s.__init.apply(s, arguments);\n}\n\n\n/** \n * Chain constructor.\n * @api pivate\n */\nfunction Chain() {\n  this.queue = [];\n  this.onend = function(err) {};\n  this.pass = true;\n} \n\n\n/**\n * Trying to Initialize the `queue` with a serial of arguments. \n *\n * @api private\n */\nChain.prototype.__init = function() {\n  this.queue = [].slice.call(arguments);\n  return this;\n}\n\n\n/**\n * Add a `job` or an array of `jobs` into the Chain.\n * A `job` is defined by a function. \n *\n * @param {Function|Array} a function or an array of functions \n * @return {Chain}\n * @api public\n */\nChain.prototype.add = function() {\n  var jobs = [].slice.call(arguments);\n  jobs.forEach(\n    (function(job) {\n      this.queue.push.apply(\n        this.queue, Array.isArray(job) ? job : [job]\n      );\n    }).bind(this)\n  );\n  return this;\n}\n\n\n/**\n * The iterator of the Chain. When it reaches end then call \n * call the callback function.\n * \n * @return {Chain}\n * @api public\n */\nChain.prototype.next = function() {\n  if (!this.pass) return this;\n  if (this.queue.length) {\n    this.queue.shift().call();    \n  } else {\n    this.onend();\n  }\n  return this;\n}  \n\n\n/**\n * Terminate the chain.\n * \n * @return {Chain}\n * @api public\n */\nChain.prototype.stop = function() {\n  this.pass = false;\n  this.onend.apply(this, arguments);\n  return this;\n}  \n \n\n/**\n * Start iterating through the Chain and ends with the  \n * given callback.\n * \n * @param {Function} end callback\n * @return {Chain} \n * @api public\n */\nChain.prototype.traverse = function(fn) {\n  fn && fn.call && fn.apply && (this.onend = fn);\n  this.next();\n  return this;\n}\n\n"]},"metadata":{},"sourceType":"script"}