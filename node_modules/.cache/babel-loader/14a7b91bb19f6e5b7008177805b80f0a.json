{"ast":null,"code":"import camelCase from \"camelcase\";\nimport * as borsh from \"@project-serum/borsh\";\nimport { IdlCoder } from \"./idl\";\nimport { sighash } from \"./common\";\n/**\n * Namespace for state method function signatures.\n */\n\nexport const SIGHASH_STATE_NAMESPACE = \"state\";\n/**\n * Namespace for global instruction function signatures (i.e. functions\n * that aren't namespaced by the state or any of its trait implementations).\n */\n\nexport const SIGHASH_GLOBAL_NAMESPACE = \"global\";\n/**\n * Encodes and decodes program instructions.\n */\n\nexport class InstructionCoder {\n  constructor(idl) {\n    this.ixLayout = InstructionCoder.parseIxLayout(idl);\n  }\n  /**\n   * Encodes a program instruction.\n   */\n\n\n  encode(ixName, ix) {\n    return this._encode(SIGHASH_GLOBAL_NAMESPACE, ixName, ix);\n  }\n  /**\n   * Encodes a program state instruction.\n   */\n\n\n  encodeState(ixName, ix) {\n    return this._encode(SIGHASH_STATE_NAMESPACE, ixName, ix);\n  }\n\n  _encode(nameSpace, ixName, ix) {\n    const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n\n    const methodName = camelCase(ixName);\n    const len = this.ixLayout.get(methodName).encode(ix, buffer);\n    const data = buffer.slice(0, len);\n    return Buffer.concat([sighash(nameSpace, ixName), data]);\n  }\n\n  static parseIxLayout(idl) {\n    const stateMethods = idl.state ? idl.state.methods : [];\n    const ixLayouts = stateMethods.map(m => {\n      let fieldLayouts = m.args.map(arg => {\n        return IdlCoder.fieldLayout(arg, idl.types);\n      });\n      const name = camelCase(m.name);\n      return [name, borsh.struct(fieldLayouts, name)];\n    }).concat(idl.instructions.map(ix => {\n      let fieldLayouts = ix.args.map(arg => IdlCoder.fieldLayout(arg, idl.types));\n      const name = camelCase(ix.name);\n      return [name, borsh.struct(fieldLayouts, name)];\n    })); // @ts-ignore\n\n    return new Map(ixLayouts);\n  }\n\n}","map":{"version":3,"sources":["../../../src/coder/instruction.ts"],"names":[],"mappings":"AAAA,OAAO,SAAP,MAAsB,WAAtB;AAEA,OAAO,KAAK,KAAZ,MAAuB,sBAAvB;AAEA,SAAS,QAAT,QAAyB,OAAzB;AACA,SAAS,OAAT,QAAwB,UAAxB;AAEA;;AAEG;;AACH,OAAO,MAAM,uBAAuB,GAAG,OAAhC;AACP;;;AAGG;;AACH,OAAO,MAAM,wBAAwB,GAAG,QAAjC;AAEP;;AAEG;;AACH,OAAM,MAAO,gBAAP,CAAuB;AAM3B,EAAA,WAAA,CAAmB,GAAnB,EAA2B;AACzB,SAAK,QAAL,GAAgB,gBAAgB,CAAC,aAAjB,CAA+B,GAA/B,CAAhB;AACD;AAED;;AAEG;;;AACI,EAAA,MAAM,CAAC,MAAD,EAAiB,EAAjB,EAAwB;AACnC,WAAO,KAAK,OAAL,CAAa,wBAAb,EAAuC,MAAvC,EAA+C,EAA/C,CAAP;AACD;AAED;;AAEG;;;AACI,EAAA,WAAW,CAAC,MAAD,EAAiB,EAAjB,EAAwB;AACxC,WAAO,KAAK,OAAL,CAAa,uBAAb,EAAsC,MAAtC,EAA8C,EAA9C,CAAP;AACD;;AAEO,EAAA,OAAO,CAAC,SAAD,EAAoB,MAApB,EAAoC,EAApC,EAA2C;AACxD,UAAM,MAAM,GAAG,MAAM,CAAC,KAAP,CAAa,IAAb,CAAf,CADwD,CACrB;;AACnC,UAAM,UAAU,GAAG,SAAS,CAAC,MAAD,CAA5B;AACA,UAAM,GAAG,GAAG,KAAK,QAAL,CAAc,GAAd,CAAkB,UAAlB,EAA8B,MAA9B,CAAqC,EAArC,EAAyC,MAAzC,CAAZ;AACA,UAAM,IAAI,GAAG,MAAM,CAAC,KAAP,CAAa,CAAb,EAAgB,GAAhB,CAAb;AACA,WAAO,MAAM,CAAC,MAAP,CAAc,CAAC,OAAO,CAAC,SAAD,EAAY,MAAZ,CAAR,EAA6B,IAA7B,CAAd,CAAP;AACD;;AAE2B,SAAb,aAAa,CAAC,GAAD,EAAS;AACnC,UAAM,YAAY,GAAG,GAAG,CAAC,KAAJ,GAAY,GAAG,CAAC,KAAJ,CAAU,OAAtB,GAAgC,EAArD;AAEA,UAAM,SAAS,GAAG,YAAY,CAC3B,GADe,CACV,CAAD,IAAsB;AACzB,UAAI,YAAY,GAAG,CAAC,CAAC,IAAF,CAAO,GAAP,CAAY,GAAD,IAAkB;AAC9C,eAAO,QAAQ,CAAC,WAAT,CAAqB,GAArB,EAA0B,GAAG,CAAC,KAA9B,CAAP;AACD,OAFkB,CAAnB;AAGA,YAAM,IAAI,GAAG,SAAS,CAAC,CAAC,CAAC,IAAH,CAAtB;AACA,aAAO,CAAC,IAAD,EAAO,KAAK,CAAC,MAAN,CAAa,YAAb,EAA2B,IAA3B,CAAP,CAAP;AACD,KAPe,EAQf,MARe,CASd,GAAG,CAAC,YAAJ,CAAiB,GAAjB,CAAsB,EAAD,IAAO;AAC1B,UAAI,YAAY,GAAG,EAAE,CAAC,IAAH,CAAQ,GAAR,CAAa,GAAD,IAC7B,QAAQ,CAAC,WAAT,CAAqB,GAArB,EAA0B,GAAG,CAAC,KAA9B,CADiB,CAAnB;AAGA,YAAM,IAAI,GAAG,SAAS,CAAC,EAAE,CAAC,IAAJ,CAAtB;AACA,aAAO,CAAC,IAAD,EAAO,KAAK,CAAC,MAAN,CAAa,YAAb,EAA2B,IAA3B,CAAP,CAAP;AACD,KAND,CATc,CAAlB,CAHmC,CAoBnC;;AACA,WAAO,IAAI,GAAJ,CAAQ,SAAR,CAAP;AACD;;AAtD0B","sourceRoot":"","sourcesContent":["import camelCase from \"camelcase\";\nimport * as borsh from \"@project-serum/borsh\";\nimport { IdlCoder } from \"./idl\";\nimport { sighash } from \"./common\";\n/**\n * Namespace for state method function signatures.\n */\nexport const SIGHASH_STATE_NAMESPACE = \"state\";\n/**\n * Namespace for global instruction function signatures (i.e. functions\n * that aren't namespaced by the state or any of its trait implementations).\n */\nexport const SIGHASH_GLOBAL_NAMESPACE = \"global\";\n/**\n * Encodes and decodes program instructions.\n */\nexport class InstructionCoder {\n    constructor(idl) {\n        this.ixLayout = InstructionCoder.parseIxLayout(idl);\n    }\n    /**\n     * Encodes a program instruction.\n     */\n    encode(ixName, ix) {\n        return this._encode(SIGHASH_GLOBAL_NAMESPACE, ixName, ix);\n    }\n    /**\n     * Encodes a program state instruction.\n     */\n    encodeState(ixName, ix) {\n        return this._encode(SIGHASH_STATE_NAMESPACE, ixName, ix);\n    }\n    _encode(nameSpace, ixName, ix) {\n        const buffer = Buffer.alloc(1000); // TODO: use a tighter buffer.\n        const methodName = camelCase(ixName);\n        const len = this.ixLayout.get(methodName).encode(ix, buffer);\n        const data = buffer.slice(0, len);\n        return Buffer.concat([sighash(nameSpace, ixName), data]);\n    }\n    static parseIxLayout(idl) {\n        const stateMethods = idl.state ? idl.state.methods : [];\n        const ixLayouts = stateMethods\n            .map((m) => {\n            let fieldLayouts = m.args.map((arg) => {\n                return IdlCoder.fieldLayout(arg, idl.types);\n            });\n            const name = camelCase(m.name);\n            return [name, borsh.struct(fieldLayouts, name)];\n        })\n            .concat(idl.instructions.map((ix) => {\n            let fieldLayouts = ix.args.map((arg) => IdlCoder.fieldLayout(arg, idl.types));\n            const name = camelCase(ix.name);\n            return [name, borsh.struct(fieldLayouts, name)];\n        }));\n        // @ts-ignore\n        return new Map(ixLayouts);\n    }\n}\n//# sourceMappingURL=instruction.js.map"]},"metadata":{},"sourceType":"module"}