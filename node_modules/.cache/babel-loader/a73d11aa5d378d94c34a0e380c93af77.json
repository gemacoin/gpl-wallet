{"ast":null,"code":"import { PublicKey, SystemProgram, Transaction, TransactionInstruction, SYSVAR_RENT_PUBKEY } from '@solana/web3.js';\nimport { TokenInstructions } from '@project-serum/serum';\nimport { assertOwner, closeAccount, initializeAccount, initializeMint, memoInstruction, mintTo, TOKEN_PROGRAM_ID, transferChecked } from './instructions';\nimport { ACCOUNT_LAYOUT, getOwnedAccountsFilters, MINT_LAYOUT } from './data';\nexport async function getOwnedTokenAccounts(connection, publicKey) {\n  let filters = getOwnedAccountsFilters(publicKey);\n  let resp = await connection.getProgramAccounts(TOKEN_PROGRAM_ID, {\n    filters\n  });\n  return resp.map(_ref => {\n    let {\n      pubkey,\n      account: {\n        data,\n        executable,\n        owner,\n        carats\n      }\n    } = _ref;\n    return {\n      publicKey: new PublicKey(pubkey),\n      accountInfo: {\n        data,\n        executable,\n        owner: new PublicKey(owner),\n        carats\n      }\n    };\n  });\n}\nexport async function signAndSendTransaction(connection, transaction, wallet, signers) {\n  let skipPreflight = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : false;\n  transaction.recentBlockhash = (await connection.getRecentBlockhash('max')).blockhash;\n  transaction.setSigners( // fee payed by the wallet owner\n  wallet.publicKey, ...signers.map(s => s.publicKey));\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n\n  transaction = await wallet.signTransaction(transaction);\n  const rawTransaction = transaction.serialize();\n  return await connection.sendRawTransaction(rawTransaction, {\n    skipPreflight,\n    preflightCommitment: 'single'\n  });\n}\nexport async function nativeTransfer(connection, wallet, destination, amount) {\n  const tx = new Transaction().add(SystemProgram.transfer({\n    fromPubkey: wallet.publicKey,\n    toPubkey: destination,\n    carats: amount\n  }));\n  return await signAndSendTransaction(connection, tx, wallet, []);\n}\nexport async function createAndInitializeMint(_ref2) {\n  let {\n    connection,\n    owner,\n    // Wallet for paying fees and allowed to mint new tokens\n    mint,\n    // Account to hold token information\n    amount,\n    // Number of tokens to issue\n    decimals,\n    initialAccount // Account to hold newly issued tokens, if amount > 0\n\n  } = _ref2;\n  let transaction = new Transaction();\n  transaction.add(SystemProgram.createAccount({\n    fromPubkey: owner.publicKey,\n    newAccountPubkey: mint.publicKey,\n    carats: await connection.getMinimumBalanceForRentExemption(MINT_LAYOUT.span),\n    space: MINT_LAYOUT.span,\n    programId: TOKEN_PROGRAM_ID\n  }));\n  transaction.add(initializeMint({\n    mint: mint.publicKey,\n    decimals,\n    mintAuthority: owner.publicKey\n  }));\n  let signers = [mint];\n\n  if (amount > 0) {\n    transaction.add(SystemProgram.createAccount({\n      fromPubkey: owner.publicKey,\n      newAccountPubkey: initialAccount.publicKey,\n      carats: await connection.getMinimumBalanceForRentExemption(ACCOUNT_LAYOUT.span),\n      space: ACCOUNT_LAYOUT.span,\n      programId: TOKEN_PROGRAM_ID\n    }));\n    signers.push(initialAccount);\n    transaction.add(initializeAccount({\n      account: initialAccount.publicKey,\n      mint: mint.publicKey,\n      owner: owner.publicKey\n    }));\n    transaction.add(mintTo({\n      mint: mint.publicKey,\n      destination: initialAccount.publicKey,\n      amount,\n      mintAuthority: owner.publicKey\n    }));\n  }\n\n  return await signAndSendTransaction(connection, transaction, owner, signers);\n}\nexport async function createAndInitializeTokenAccount(_ref3) {\n  let {\n    connection,\n    payer,\n    mintPublicKey,\n    newAccount\n  } = _ref3;\n  let transaction = new Transaction();\n  transaction.add(SystemProgram.createAccount({\n    fromPubkey: payer.publicKey,\n    newAccountPubkey: newAccount.publicKey,\n    carats: await connection.getMinimumBalanceForRentExemption(ACCOUNT_LAYOUT.span),\n    space: ACCOUNT_LAYOUT.span,\n    programId: TOKEN_PROGRAM_ID\n  }));\n  transaction.add(initializeAccount({\n    account: newAccount.publicKey,\n    mint: mintPublicKey,\n    owner: payer.publicKey\n  }));\n  let signers = [newAccount];\n  return await signAndSendTransaction(connection, transaction, payer, signers);\n}\nexport async function createAssociatedTokenAccount(_ref4) {\n  let {\n    connection,\n    wallet,\n    splTokenMintAddress\n  } = _ref4;\n  const [ix, address] = await createAssociatedTokenAccountIx(wallet.publicKey, wallet.publicKey, splTokenMintAddress);\n  const tx = new Transaction();\n  tx.add(ix);\n  tx.feePayer = wallet.publicKey;\n  const txSig = await signAndSendTransaction(connection, tx, wallet, []);\n  return [address, txSig];\n}\n\nasync function createAssociatedTokenAccountIx(fundingAddress, walletAddress, splTokenMintAddress) {\n  const associatedTokenAddress = await findAssociatedTokenAddress(walletAddress, splTokenMintAddress);\n  const systemProgramId = new PublicKey('11111111111111111111111111111111');\n  const keys = [{\n    pubkey: fundingAddress,\n    isSigner: true,\n    isWritable: true\n  }, {\n    pubkey: associatedTokenAddress,\n    isSigner: false,\n    isWritable: true\n  }, {\n    pubkey: walletAddress,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: splTokenMintAddress,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: systemProgramId,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: TokenInstructions.TOKEN_PROGRAM_ID,\n    isSigner: false,\n    isWritable: false\n  }, {\n    pubkey: SYSVAR_RENT_PUBKEY,\n    isSigner: false,\n    isWritable: false\n  }];\n  const ix = new TransactionInstruction({\n    keys,\n    programId: ASSOCIATED_TOKEN_PROGRAM_ID,\n    data: Buffer.from([])\n  });\n  return [ix, associatedTokenAddress];\n}\n\nexport async function findAssociatedTokenAddress(walletAddress, tokenMintAddress) {\n  return (await PublicKey.findProgramAddress([walletAddress.toBuffer(), TokenInstructions.TOKEN_PROGRAM_ID.toBuffer(), tokenMintAddress.toBuffer()], ASSOCIATED_TOKEN_PROGRAM_ID))[0];\n}\nexport const ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey('ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL');\nexport async function transferTokens(_ref5) {\n  let {\n    connection,\n    owner,\n    sourcePublicKey,\n    destinationPublicKey,\n    amount,\n    memo,\n    mint,\n    decimals,\n    overrideDestinationCheck\n  } = _ref5;\n  let destinationAccountInfo = await connection.getAccountInfo(destinationPublicKey);\n\n  if (!!destinationAccountInfo && destinationAccountInfo.owner.equals(TOKEN_PROGRAM_ID)) {\n    return await transferBetweenSplTokenAccounts({\n      connection,\n      owner,\n      mint,\n      decimals,\n      sourcePublicKey,\n      destinationPublicKey,\n      amount,\n      memo\n    });\n  }\n\n  if ((!destinationAccountInfo || destinationAccountInfo.carats === 0) && !overrideDestinationCheck) {\n    throw new Error('Cannot send to address with zero GEMA balances');\n  }\n\n  const destinationAssociatedTokenAddress = await findAssociatedTokenAddress(destinationPublicKey, mint);\n  destinationAccountInfo = await connection.getAccountInfo(destinationAssociatedTokenAddress);\n\n  if (!!destinationAccountInfo && destinationAccountInfo.owner.equals(TOKEN_PROGRAM_ID)) {\n    return await transferBetweenSplTokenAccounts({\n      connection,\n      owner,\n      mint,\n      decimals,\n      sourcePublicKey,\n      destinationPublicKey: destinationAssociatedTokenAddress,\n      amount,\n      memo\n    });\n  }\n\n  return await createAndTransferToAccount({\n    connection,\n    owner,\n    sourcePublicKey,\n    destinationPublicKey,\n    amount,\n    memo,\n    mint,\n    decimals\n  });\n}\n\nfunction createTransferBetweenSplTokenAccountsInstruction(_ref6) {\n  let {\n    ownerPublicKey,\n    mint,\n    decimals,\n    sourcePublicKey,\n    destinationPublicKey,\n    amount,\n    memo\n  } = _ref6;\n  let transaction = new Transaction().add(transferChecked({\n    source: sourcePublicKey,\n    mint,\n    decimals,\n    destination: destinationPublicKey,\n    owner: ownerPublicKey,\n    amount\n  }));\n\n  if (memo) {\n    transaction.add(memoInstruction(memo));\n  }\n\n  return transaction;\n}\n\nasync function transferBetweenSplTokenAccounts(_ref7) {\n  let {\n    connection,\n    owner,\n    mint,\n    decimals,\n    sourcePublicKey,\n    destinationPublicKey,\n    amount,\n    memo\n  } = _ref7;\n  const transaction = createTransferBetweenSplTokenAccountsInstruction({\n    ownerPublicKey: owner.publicKey,\n    mint,\n    decimals,\n    sourcePublicKey,\n    destinationPublicKey,\n    amount,\n    memo\n  });\n  let signers = [];\n  return await signAndSendTransaction(connection, transaction, owner, signers);\n}\n\nasync function createAndTransferToAccount(_ref8) {\n  let {\n    connection,\n    owner,\n    sourcePublicKey,\n    destinationPublicKey,\n    amount,\n    memo,\n    mint,\n    decimals\n  } = _ref8;\n  const [createAccountInstruction, newAddress] = await createAssociatedTokenAccountIx(owner.publicKey, destinationPublicKey, mint);\n  let transaction = new Transaction();\n  transaction.add(assertOwner({\n    account: destinationPublicKey,\n    owner: SystemProgram.programId\n  }));\n  transaction.add(createAccountInstruction);\n  const transferBetweenAccountsTxn = createTransferBetweenSplTokenAccountsInstruction({\n    ownerPublicKey: owner.publicKey,\n    mint,\n    decimals,\n    sourcePublicKey,\n    destinationPublicKey: newAddress,\n    amount,\n    memo\n  });\n  transaction.add(transferBetweenAccountsTxn);\n  let signers = [];\n  return await signAndSendTransaction(connection, transaction, owner, signers);\n}\n\nexport async function closeTokenAccount(_ref9) {\n  let {\n    connection,\n    owner,\n    sourcePublicKey,\n    skipPreflight\n  } = _ref9;\n  let transaction = new Transaction().add(closeAccount({\n    source: sourcePublicKey,\n    destination: owner.publicKey,\n    owner: owner.publicKey\n  }));\n  let signers = [];\n  return await signAndSendTransaction(connection, transaction, owner, signers, skipPreflight);\n}","map":{"version":3,"sources":["/home/imentus/spl-token-wallet/src/utils/tokens/index.js"],"names":["PublicKey","SystemProgram","Transaction","TransactionInstruction","SYSVAR_RENT_PUBKEY","TokenInstructions","assertOwner","closeAccount","initializeAccount","initializeMint","memoInstruction","mintTo","TOKEN_PROGRAM_ID","transferChecked","ACCOUNT_LAYOUT","getOwnedAccountsFilters","MINT_LAYOUT","getOwnedTokenAccounts","connection","publicKey","filters","resp","getProgramAccounts","map","pubkey","account","data","executable","owner","carats","accountInfo","signAndSendTransaction","transaction","wallet","signers","skipPreflight","recentBlockhash","getRecentBlockhash","blockhash","setSigners","s","length","partialSign","signTransaction","rawTransaction","serialize","sendRawTransaction","preflightCommitment","nativeTransfer","destination","amount","tx","add","transfer","fromPubkey","toPubkey","createAndInitializeMint","mint","decimals","initialAccount","createAccount","newAccountPubkey","getMinimumBalanceForRentExemption","span","space","programId","mintAuthority","push","createAndInitializeTokenAccount","payer","mintPublicKey","newAccount","createAssociatedTokenAccount","splTokenMintAddress","ix","address","createAssociatedTokenAccountIx","feePayer","txSig","fundingAddress","walletAddress","associatedTokenAddress","findAssociatedTokenAddress","systemProgramId","keys","isSigner","isWritable","ASSOCIATED_TOKEN_PROGRAM_ID","Buffer","from","tokenMintAddress","findProgramAddress","toBuffer","transferTokens","sourcePublicKey","destinationPublicKey","memo","overrideDestinationCheck","destinationAccountInfo","getAccountInfo","equals","transferBetweenSplTokenAccounts","Error","destinationAssociatedTokenAddress","createAndTransferToAccount","createTransferBetweenSplTokenAccountsInstruction","ownerPublicKey","source","createAccountInstruction","newAddress","transferBetweenAccountsTxn","closeTokenAccount"],"mappings":"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","sourcesContent":["import {\n  PublicKey,\n  SystemProgram,\n  Transaction,\n  TransactionInstruction,\n  SYSVAR_RENT_PUBKEY,\n} from '@solana/web3.js';\nimport { TokenInstructions } from '@project-serum/serum';\nimport {\n  assertOwner,\n  closeAccount,\n  initializeAccount,\n  initializeMint,\n  memoInstruction,\n  mintTo,\n  TOKEN_PROGRAM_ID,\n  transferChecked,\n} from './instructions';\nimport { ACCOUNT_LAYOUT, getOwnedAccountsFilters, MINT_LAYOUT } from './data';\n\nexport async function getOwnedTokenAccounts(connection, publicKey) {\n  let filters = getOwnedAccountsFilters(publicKey);\n  let resp = await connection.getProgramAccounts(\n    TOKEN_PROGRAM_ID,\n    {\n      filters,\n    },\n  );\n  return resp\n    .map(({ pubkey, account: { data, executable, owner, carats } }) => ({\n      publicKey: new PublicKey(pubkey),\n      accountInfo: {\n        data,\n        executable,\n        owner: new PublicKey(owner),\n        carats,\n      },\n    }))\n}\n\nexport async function signAndSendTransaction(\n  connection,\n  transaction,\n  wallet,\n  signers,\n  skipPreflight = false,\n) {\n  transaction.recentBlockhash = (\n    await connection.getRecentBlockhash('max')\n  ).blockhash;\n  transaction.setSigners(\n    // fee payed by the wallet owner\n    wallet.publicKey,\n    ...signers.map((s) => s.publicKey),\n  );\n\n  if (signers.length > 0) {\n    transaction.partialSign(...signers);\n  }\n\n  transaction = await wallet.signTransaction(transaction);\n  const rawTransaction = transaction.serialize();\n  return await connection.sendRawTransaction(rawTransaction, {\n    skipPreflight,\n    preflightCommitment: 'single',\n  });\n}\n\nexport async function nativeTransfer(connection, wallet, destination, amount) {\n  const tx = new Transaction().add(\n    SystemProgram.transfer({\n      fromPubkey: wallet.publicKey,\n      toPubkey: destination,\n      carats: amount,\n    }),\n  );\n  return await signAndSendTransaction(connection, tx, wallet, []);\n}\n\nexport async function createAndInitializeMint({\n  connection,\n  owner, // Wallet for paying fees and allowed to mint new tokens\n  mint, // Account to hold token information\n  amount, // Number of tokens to issue\n  decimals,\n  initialAccount, // Account to hold newly issued tokens, if amount > 0\n}) {\n  let transaction = new Transaction();\n  transaction.add(\n    SystemProgram.createAccount({\n      fromPubkey: owner.publicKey,\n      newAccountPubkey: mint.publicKey,\n      carats: await connection.getMinimumBalanceForRentExemption(\n        MINT_LAYOUT.span,\n      ),\n      space: MINT_LAYOUT.span,\n      programId: TOKEN_PROGRAM_ID,\n    }),\n  );\n  transaction.add(\n    initializeMint({\n      mint: mint.publicKey,\n      decimals,\n      mintAuthority: owner.publicKey,\n    }),\n  );\n  let signers = [mint];\n  if (amount > 0) {\n    transaction.add(\n      SystemProgram.createAccount({\n        fromPubkey: owner.publicKey,\n        newAccountPubkey: initialAccount.publicKey,\n        carats: await connection.getMinimumBalanceForRentExemption(\n          ACCOUNT_LAYOUT.span,\n        ),\n        space: ACCOUNT_LAYOUT.span,\n        programId: TOKEN_PROGRAM_ID,\n      }),\n    );\n    signers.push(initialAccount);\n    transaction.add(\n      initializeAccount({\n        account: initialAccount.publicKey,\n        mint: mint.publicKey,\n        owner: owner.publicKey,\n      }),\n    );\n    transaction.add(\n      mintTo({\n        mint: mint.publicKey,\n        destination: initialAccount.publicKey,\n        amount,\n        mintAuthority: owner.publicKey,\n      }),\n    );\n  }\n\n  return await signAndSendTransaction(connection, transaction, owner, signers);\n}\n\nexport async function createAndInitializeTokenAccount({\n  connection,\n  payer,\n  mintPublicKey,\n  newAccount,\n}) {\n  let transaction = new Transaction();\n  transaction.add(\n    SystemProgram.createAccount({\n      fromPubkey: payer.publicKey,\n      newAccountPubkey: newAccount.publicKey,\n      carats: await connection.getMinimumBalanceForRentExemption(\n        ACCOUNT_LAYOUT.span,\n      ),\n      space: ACCOUNT_LAYOUT.span,\n      programId: TOKEN_PROGRAM_ID,\n    }),\n  );\n  transaction.add(\n    initializeAccount({\n      account: newAccount.publicKey,\n      mint: mintPublicKey,\n      owner: payer.publicKey,\n    }),\n  );\n\n  let signers = [newAccount];\n  return await signAndSendTransaction(connection, transaction, payer, signers);\n}\n\nexport async function createAssociatedTokenAccount({\n  connection,\n  wallet,\n  splTokenMintAddress,\n}) {\n  const [ix, address] = await createAssociatedTokenAccountIx(\n    wallet.publicKey,\n    wallet.publicKey,\n    splTokenMintAddress,\n  );\n  const tx = new Transaction();\n  tx.add(ix);\n  tx.feePayer = wallet.publicKey;\n  const txSig = await signAndSendTransaction(connection, tx, wallet, []);\n\n  return [address, txSig];\n}\nasync function createAssociatedTokenAccountIx(\n  fundingAddress,\n  walletAddress,\n  splTokenMintAddress,\n) {\n  const associatedTokenAddress = await findAssociatedTokenAddress(\n    walletAddress,\n    splTokenMintAddress,\n  );\n  const systemProgramId = new PublicKey('11111111111111111111111111111111');\n  const keys = [\n    {\n      pubkey: fundingAddress,\n      isSigner: true,\n      isWritable: true,\n    },\n    {\n      pubkey: associatedTokenAddress,\n      isSigner: false,\n      isWritable: true,\n    },\n    {\n      pubkey: walletAddress,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: splTokenMintAddress,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: systemProgramId,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: TokenInstructions.TOKEN_PROGRAM_ID,\n      isSigner: false,\n      isWritable: false,\n    },\n    {\n      pubkey: SYSVAR_RENT_PUBKEY,\n      isSigner: false,\n      isWritable: false,\n    },\n  ];\n  const ix = new TransactionInstruction({\n    keys,\n    programId: ASSOCIATED_TOKEN_PROGRAM_ID,\n    data: Buffer.from([]),\n  });\n  return [ix, associatedTokenAddress];\n}\n\nexport async function findAssociatedTokenAddress(\n  walletAddress,\n  tokenMintAddress,\n) {\n  return (\n    await PublicKey.findProgramAddress(\n      [\n        walletAddress.toBuffer(),\n        TokenInstructions.TOKEN_PROGRAM_ID.toBuffer(),\n        tokenMintAddress.toBuffer(),\n      ],\n      ASSOCIATED_TOKEN_PROGRAM_ID,\n    )\n  )[0];\n}\n\nexport const ASSOCIATED_TOKEN_PROGRAM_ID = new PublicKey(\n  'ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL',\n);\n\nexport async function transferTokens({\n  connection,\n  owner,\n  sourcePublicKey,\n  destinationPublicKey,\n  amount,\n  memo,\n  mint,\n  decimals,\n  overrideDestinationCheck,\n}) {\n  let destinationAccountInfo = await connection.getAccountInfo(\n    destinationPublicKey,\n  );\n  if (\n    !!destinationAccountInfo &&\n    destinationAccountInfo.owner.equals(TOKEN_PROGRAM_ID)\n  ) {\n    return await transferBetweenSplTokenAccounts({\n      connection,\n      owner,\n      mint,\n      decimals,\n      sourcePublicKey,\n      destinationPublicKey,\n      amount,\n      memo,\n    });\n  }\n\n  if (\n    (!destinationAccountInfo || destinationAccountInfo.carats === 0) &&\n    !overrideDestinationCheck\n  ) {\n    throw new Error('Cannot send to address with zero GEMA balances');\n  }\n\n  const destinationAssociatedTokenAddress = await findAssociatedTokenAddress(\n    destinationPublicKey,\n    mint,\n  );\n  destinationAccountInfo = await connection.getAccountInfo(\n    destinationAssociatedTokenAddress,\n  );\n  if (\n    !!destinationAccountInfo &&\n    destinationAccountInfo.owner.equals(TOKEN_PROGRAM_ID)\n  ) {\n    return await transferBetweenSplTokenAccounts({\n      connection,\n      owner,\n      mint,\n      decimals,\n      sourcePublicKey,\n      destinationPublicKey: destinationAssociatedTokenAddress,\n      amount,\n      memo,\n    });\n  }\n  return await createAndTransferToAccount({\n    connection,\n    owner,\n    sourcePublicKey,\n    destinationPublicKey,\n    amount,\n    memo,\n    mint,\n    decimals,\n  });\n}\n\nfunction createTransferBetweenSplTokenAccountsInstruction({\n  ownerPublicKey,\n  mint,\n  decimals,\n  sourcePublicKey,\n  destinationPublicKey,\n  amount,\n  memo,\n}) {\n  let transaction = new Transaction().add(\n    transferChecked({\n      source: sourcePublicKey,\n      mint,\n      decimals,\n      destination: destinationPublicKey,\n      owner: ownerPublicKey,\n      amount,\n    }),\n  );\n  if (memo) {\n    transaction.add(memoInstruction(memo));\n  }\n  return transaction;\n}\n\nasync function transferBetweenSplTokenAccounts({\n  connection,\n  owner,\n  mint,\n  decimals,\n  sourcePublicKey,\n  destinationPublicKey,\n  amount,\n  memo,\n}) {\n  const transaction = createTransferBetweenSplTokenAccountsInstruction({\n    ownerPublicKey: owner.publicKey,\n    mint,\n    decimals,\n    sourcePublicKey,\n    destinationPublicKey,\n    amount,\n    memo,\n  });\n  let signers = [];\n  return await signAndSendTransaction(connection, transaction, owner, signers);\n}\n\nasync function createAndTransferToAccount({\n  connection,\n  owner,\n  sourcePublicKey,\n  destinationPublicKey,\n  amount,\n  memo,\n  mint,\n  decimals,\n}) {\n  const [\n    createAccountInstruction,\n    newAddress,\n  ] = await createAssociatedTokenAccountIx(\n    owner.publicKey,\n    destinationPublicKey,\n    mint,\n  );\n  let transaction = new Transaction();\n  transaction.add(\n    assertOwner({\n      account: destinationPublicKey,\n      owner: SystemProgram.programId,\n    }),\n  );\n  transaction.add(createAccountInstruction);\n  const transferBetweenAccountsTxn = createTransferBetweenSplTokenAccountsInstruction(\n    {\n      ownerPublicKey: owner.publicKey,\n      mint,\n      decimals,\n      sourcePublicKey,\n      destinationPublicKey: newAddress,\n      amount,\n      memo,\n    },\n  );\n  transaction.add(transferBetweenAccountsTxn);\n  let signers = [];\n  return await signAndSendTransaction(connection, transaction, owner, signers);\n}\n\nexport async function closeTokenAccount({\n  connection,\n  owner,\n  sourcePublicKey,\n  skipPreflight,\n}) {\n  let transaction = new Transaction().add(\n    closeAccount({\n      source: sourcePublicKey,\n      destination: owner.publicKey,\n      owner: owner.publicKey,\n    }),\n  );\n  let signers = [];\n  return await signAndSendTransaction(\n    connection,\n    transaction,\n    owner,\n    signers,\n    skipPreflight,\n  );\n}\n"]},"metadata":{},"sourceType":"module"}